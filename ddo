#!/bin/bash -i

# TODO: general script header docs

# TODO: developer documentation: command and preflight function patterns.

declare -r SCRIPTHOME="$HOME/.ddo"
declare -r SCRIPTPATH=$0
declare -r PROGRAM=$(basename ${0})
declare -r TTY="$(tty | sed -e "s/.*tty\(.*\)/\1/")"
declare -r USER_COMMANDS="init init7 init8 servers addserver modserver delserver update help keyexchange"
declare -r SERVER_COMMANDS="ping init_vhost keyexchange_rsa apache2_init mysql_scan"
declare -r DEPS="dd od tee cat ssh awk grep sed wget git tbl groff tr"
declare -r TEMPDIR="$(mktemp -d /tmp/ddo.XXXXXXXXXX)"
trap 'rm -rf "$TEMPDIR"' EXIT INT TERM HUP

declare user
[ -n "$USERNAME" ] && user="$USERNAME"
[ -n "$USER" ] && user="$USER"
REMOTE=0
declare -a PREFLIGHT_ERRORS
declare -a PREFLIGHT_WARNINGS
flightcheck=0
declare -a commands
declare invalid_commands
SED="sed" # needed because ns uses it, will be replaced in deps processing.

#------------------------------------------------------------------------------
# Utilities
#------------------------------------------------------------------------------

# ---------------------
# get(varname, default)
# ---------------------
#
# Utility: Syntax sugar to read variable and supply a default if it is not set.
#
# ARGS:  - varname: Variable name.
#
#        - default: Default value if ${!varname} is not set.
#
# STDIN:   Unused
#
# STDOUT:  Variable value or default.
#
# VARS:    None
#
# DEPS:    None
#
# RETURN:  Unused (always resolves true).
#
# USAGE EXAMPLE:
#
#   unset VAR
#   var=$(get VAR "default value")
#   echo $var # "default value"
#   VAR="my value"
#   var=$(get VAR "default value")
#   echo $var # "my value"
#
function get {
  var="$1"
  [ -n "${!var}" ] && echo "${!var}" || echo "$2"
}

function index {
  var="$1"
  deref="${!var}"
  echo "var: ${deref[@]}" >> "${TTY}"
  [ -n "${!var[$2]}" ] && printf "${!var[$2]}" || printf "$3"
}

# ----------------------
# repeat(ntimes, string)
# ----------------------
#
# Utility: Repeat a string some specified number of times. To preserve
# whitespace in output, quote the call: "$(repeat 5 ' hi ')".
#
# ARGS:  - ntimes: How many times to repeat the string. Must be an integer
#                  value greater than zero.
#
#        - string: String to repeat.
#
# STDIN:   Unused
#
# STDOUT:  Repeated string.
#
# VARS:    None
#
# DEPS:    None
#
# RETURN:  Unused (always resolves true).
#
# USAGE EXAMPLE:
#
#   repeat 5 "hello"        # "hellohellohellohellohello"
#   repeat 5 "hello  "      # "hello hello hello hello hello"
#   "$(repeat 5 'hello  ')" # "hello  hello  hello  hello  hello  "
#
function repeat {
  # TODO: validate that $1 is an integer and is >= 0.
  [ "$2" = $'\n' ] && v=$'\n ' || v="$2"
  unset str
  for i in $(seq 1 $1); do
    str+="$v"
  done
  printf '%b' "$str"
}

# ------------------
# loadserver(server)
# ------------------
#
# Utility: Load server settings.
#
# ARGS:  - server: Server alias.
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    ${!server}_alias: Server alias.
#          ${!server}_host: Server host.
#          ${!server}_user: Server user.
#          ${!server}_identity: Server identity.
#          ${!server}_options: Server options.
#
# DEPS:    None
#
# RETURN:  0 if data successfully loaded, 1 otherwise (bash `if` compatible).
#
# USAGE EXAMPLE:
#
#     loadserver "${server}" ||
#       fatal "Could not read server configuraion for '${server}'."
#     identity=$(get $(ns ${server} _identity))
#     user=$(get $(ns ${server} _user))
#     host=$(get $(ns ${server} _host))
#     opts=$(get $(ns ${server} _sshopts))
#
function loadserver {
  file="$SCRIPTHOME/servers/${1}.server"
  [ -f "$file" ] || return 1
  . "$file" || return 1
  n=$(ns ${1} _alias); export $n="${!n}"
  n=$(ns ${1} _host); export $n="${!n}"
  n=$(ns ${1} _user); export $n="${!n}"
  n=$(ns ${1} _identity); export $n="${!n}"
  n=$(ns ${1} _options); export $n="${!n}"
  # TODO test required values and check alias against $1
  return 0
}

# TODO documentation.
function makepipe {
  local pipe="$TEMPDIR/$1"
  mkfifo "${pipe}"
  local rval=$?
  printf "${pipe}"
  return ${rval}
}

# -------------------------------------------------------
# ssh_pw_required(host, user, identity_file, ssh_options)
# -------------------------------------------------------
#
# Utility: Test if a particular user@host requires a password for SSH access.
#
# ARGS:  - user: ssh username
#
#        - host: ssh host
#
#        - identity_file: ssh .pem identity file (-i) (optional). If a valid
#          identity file is supplied this function returns false (nonzero).
#
#        - ssh_options: additional ssh options (optional).
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    None
#
# DEPS:    ssh
#
# RETURN:  0 if password is required, 1 otherwise (bash `if` compatible).
#
# USAGE EXAMPLE:
#
#   ssh_pw_required "fletch" "mysite.com" &&
#     echo "A password is required to login to mysite.com with user fletch."
#
function ssh_pw_required {
  args="-n -o PasswordAuthentication=no"
  [ -f "${3}" ] && args+=" -i ${3}"
  [ -n "${4}" ] && args+=" ${4}"
  args+=" -l ${2} ${1}"
  ! ${SSH} $args 2> /dev/null # Invert to answer the question of the function.
}

# -----------------------
# sshcmd(host, user, ...)
# -----------------------
#
# Utility: Low level remote access function. Most code should use `remote`.
# TODO: pass PROGRAM and COLUMNS to remote via (hidden?) command line switches.
#
# ARGS:  - host: SSH host.
#
#        - user: SSH username.
#
#        - ...: server commands and arguments, commands separated by "--".
#
# STDIN:   Unused
#
# STDOUT:  Remote command(s) output.
#
# VARS:    $IDENTITY_FILE: SSH .pem identity file (-i)
#
#          $SSH_OPTIONS: additional SSH options
#
# DEPS:    ssh
#
# RETURN:  0 if the command(s) succeeded or a nonzero error status otherwise.
#
# USAGE EXAMPLE:
#
#   sshcmd mysite.com fletch ping # Prints `uname -a` from the server.
#
function sshcmd {
  local host=$1; shift
  local user=$1; shift
  local options=$(get SSH_OPTIONS)
  local identity=$(get IDENTITY_FILE)
  [ -f "$identity" ] && options+=" -i ${identity}"
  [ -n "$user" ] && options+=" -l ${user}"
  options+=" ${host}"
  local script="REMOTE_ARGUMENTS=( $(printf " %q" "$@") )"$'\n'
  script+="$(cat "$SCRIPTPATH")"$'\n'
  # So far this rather clumsy method of passing the entire script as the
  # command string is the only way to achieve copying this file to the server
  # and running it in a single shot. Attempts to do it using stdin break
  # SSH's pty and then prompting functions and sudo fail to work on remote.
  # Still looking for a nicer way to achieve it.
  ${SSH} -Ctt ${options} "${script}"
}

# -------------------
# remote(server, ...)
# -------------------
#
# Utility: Remote access.
#
#              ---- TODO MORE COMPLETE, UPDATE THESE DOCS ----
#
# ARGS:  - server: Server alias.
#
#        - ...: server commands and arguments, commands separated by "--".
#
# STDIN:   Unused
#
# STDOUT:  Remote command(s) output.
#
# VARS:    None
#
# DEPS:    ssh
#
# RETURN:  0 if the command(s) succeeded or a nonzero error status otherwise.
#          255 if the specified server info could not be loaded.
#
# USAGE EXAMPLE:
#
#   remote mysite ping # Prints `uname -a` from the server.
#
function remote {
  local -r server="${1}"; shift
  loadserver "${server}" || return 255
  local -r identity="$(get $(ns ${server} _identity))"
  local -r options="$(get $(ns ${server} _sshopts))"
  local -r user="$(get $(ns ${server} _user))"
  local -r host="$(get $(ns ${server} _host))"
  IDENTITY_FILE="${identity}" SSH_OPTIONS="${options}" \
    sshcmd "${host}" "${user}" --remote "$@"
}

# -----------------------
# prog(variable, program)
# -----------------------
#
# Utility: Check for the existence of 'program'. If the program exists, this
# function will export 'variable' to the path of the program and return 0 (bash
# `if` compatible). If 'program' doesn't exist it returns 1 and exports nothing.
#
# ARGS:  - variable: Name of a variable to export.
#
#        - program: Program to check for.
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    None
#
# DEPS:    None
#
# RETURN:  0 if the program exists, 1 otherwise (bash `if` compatible).
#
# USAGE EXAMPLES:
#
#   prog ENV env || fatal "NO ENV HOLY CRAP WHATDO!"
#   echo ENV: $ENV
#
function prog {
  cmd="$(command -v $2)"
  [ ! -f "$cmd" ] && cmd="$(which $2 2> /dev/null)" # $(command) doesn't work when alias.
  [ ! -f "$cmd" ] && return -1 # $(command) and $(which) failed, bail.
  [ -x "$cmd" ]
  rval=$?
  [ $rval ] && export $1="$(command -v $2)"
  return $rval
}

# ------------------------------
# func(function)
# ------------------------------
#
# Utility: Test if local function is defined.
#
# ARGS:  - function: Function name to check for.
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    None
#
# DEPS:    None
#
# RETURN:  0 if the function exists, 1 otherwise (bash `if` compatible).
#
# USAGE EXAMPLES:
#
#   if func $(ns $COMMAND _myhook); then
#     $(ns $COMMAND _myhook) arg arg arg
#   fi
#
function func {
#  [ "$(type -t $1)" = "function" ]
  local -f $1 > /dev/null
  return $?
}

# -------
# ns(...)
# -------
#
# Utility: Squeeze arguments together to make a namespaced function or variable
# name. Used to build dynamic names.
#
# ARGS:  - ... names to concatinate.
#
# STDIN:   Unused
#
# STDOUT:  Generated function name.
#
# VARS:    None
#
# DEPS:    sed
#
# RETURN:  Unused
#
# USAGE EXAMPLES:
#
#    $(ns "n" "s")                              -->  `ns`
#    $(ns "ns") arg arg arg                     -->  argargarg
#    $(ns "n" "s") arg arg arg                  -->  argargarg
#    $(ns "echo") arg arg arg                   -->  arg arg arg
#    $(ns "ec" "ho") arg arg arg                -->  arg arg arg
#    echo "++ $($(ns "n" "s") arg arg arg) ++"  -->  ++ argargarg ++
#    echo "++ `$(ns "n" "s") arg arg arg` ++"   -->  ++ argargarg ++
#
function ns {
  ${SED} "s/\s//g" <<< "$@"
}

# -------------
# tableformat()
# -------------
#
# Utility: Format a table.
#
# ARGS:    None
#
# STDIN:   Stream of line(s) containing records. Cells are separated with a
#          "|" character. A row can consist of a single "-", "_", or "="
#          character which will be replaced with a separator line. Blank lines
#          are ignored. Extra whitespace around cell values is removed and
#          multiple spaces in the cell value are replaced with one.
#
# STDOUT:  Formatted table.
#
# VARS:    $WIDTH: Width of the table. Actual width of the table will be
#          smaller than this value by (MARGIN*2). The default value is
#          $COLUMNS if that variable is set, or 80 if not.
#
#          $MARGIN: Spaces to the left and right of the table. Default is 5.
#
#          $SEPARATOR: Character to separate records in input. Default is "|".
#
#          $ROWSPACING: Add space between rows. Default is 0.
#
#          $OPTIONS: 'Global options' from `tbl`. See `man tbl` for details.
#
#          $FORMAT: Table format specification from `tbl` for table body rows.
#          See `man tbl` for details.
#
#          $HEADER_FORMAT: Table format specification from `tbl` for the table
#          header row. See `man tbl` for details.
#
#          $OUTPUT_MODE: 'ascii' or 'utf8'. Default is utf8 which makes nicer
#          borders and bold/italics but may not work everywhere.
#
# DEPS:    sed tr tbl groff
#
# RETURN:  Unused
#
# USAGE EXAMPLES:
#
#   ---------
#   Example 1
#   ---------
#
#   echo -e "\n"
#   FORMAT="l lx" tableformat <<EOF
#     Arguments|
#
#     --someoption,-s | This is an option value with a really really long \
#                       description. It just keeps going. You know I think I \
#                       write more documentation and help strings than actual \
#                       code.
#
#     --another,-a    | Another option let's make a nice table.
#   EOF
#
#   # ... outputs ...
#
#     Arguments
#
#     --someoption,-s   This  is  an option value with a really really long
#                       description. It just keeps going. You know I  think
#                       I  write  more  documentation and help strings than
#                       actual code.
#
#     --another,-a      Another option let’s make a nice table.
#
#   ---------
#   Example 2
#   ---------
#
#   FORMAT="l|lx" HEADER_FORMAT="lb|lb" tableformat <<EOF
#     Abc|Def
#     _
#     --someoption,-s | This is an option value with a really really long \
#                       description. It just keeps going. You know I think I \
#                       write more documentation and help strings than actual \
#                       code.
#     --another,-a    | Another option let's make a nice table. \
#                       `printf " well hello there%.s" {1..30}`
#   EOF
#
#   # ... outputs ...
#
#     Abc             │ Def
#     ────────────────┼─────────────────────────────────────────────────────
#     --someoption,-s │ This  is  an option value with a really really long
#                     │ description. It just keeps going. You know I  think
#                     │ I  write  more  documentation and help strings than
#                     │ actual code.
#     --another,-a    │ Another option let’s make a nice table. well  hello
#                     │ there  well hello there well hello there well hello
#                     │ there well hello there well hello there well  hello
#                     │ there  well hello there well hello there well hello
#                     │ there well hello there well hello there well  hello
#                     │ there  well hello there well hello there well hello
#                     │ there well hello there well hello there well  hello
#                     │ there  well hello there well hello there well hello
#                     │ there well hello there well hello there well  hello
#                     │ there  well hello there well hello there well hello
#                     │ there well hello there well hello there
#
#   ---------
#   Example 3
#   ---------
#
#   OPTIONS="allbox" FORMAT="cw3 cw3 cw3" tableformat <<EOF
#     a | b | c
#     d | e | f
#     g | h | i
#   EOF
#
#   # ... outputs ...
#
#     ┌────┬─────┬─────┐
#     │ a  │  b  │  c  │
#     ├────┼─────┼─────┤
#     │ d  │  e  │  f  │
#     ├────┼─────┼─────┤
#     │ g  │  h  │  i  │
#     └────┴─────┴─────┘
#
function tableformat {

  # Variables init.
  ncolumns=0
  unset body
  tab="`echo -e "\t"`"
  margin=$(get MARGIN 5)
  width=$(get WIDTH $(get COLUMNS 80))
  width=$(($width-$margin-$margin-1))
  rowspacing="$(repeat $(get ROWSPACING 0) $'\n')"
  sep=$(get SEPARATOR '|')
  mode=$(get OUTPUT_MODE utf8)

  # Read records from stdin. Count columns.
  while IFS="$sep" read -a a; do
    [ ${#a[@]} = 0 ] && continue
    i=0
    for field in "${a[@]}"; do
      # TODO figure out how to get rid of `echo -e` here.
      i=$((i+1))
      v="$(echo -e "${field}" | ${SED} -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | ${TR} -s ' ')"
      [ -z "${v}" ] && continue
      [ $i -gt 1 ] && body+="${tab}"
      [ ${#v} = 1 ] &&
        body+="${v}${rowspacing}" ||
        body+=$'T{\n'"${v}${rowspacing}"$'\nT}'
    done
    body+=$'\n'
    ncolumns=$(($i>$ncolumns?$i:$ncolumns))
  done

  # Format strings.
  header=".ll ${width}m"$'\n'
  header+=".po ${margin}m"$'\n'
  header+=$'.pl 999999\n'
  header+=$'.TS\n'
  [ -n "$OPTIONS" ] && header+="$OPTIONS"$';\n'
  [ -n "$HEADER_FORMAT" ] && header+="$HEADER_FORMAT"$'\n'
  [ -n "$FORMAT" ] && \
    header+="$FORMAT"$'.\n' || \
    header+="$(repeat $ncolumns 'lex ')"$'.\n'
  footer=$'.TE'
  footer+=$'\n.pl \\n[nl]u'
  fmtstr="${header}${body}${footer}"

  # Use `tbl | groff` for formatting. `grotty` seems to have a spurious error
  # sometimes so /dev/null STDERR on groff (which calls grotty).
  #echo "${fmtstr}"
  ${TBL} <<< "${fmtstr}" | ${GROFF} "-T${mode}" 2>/dev/null
}

# -----------
# paragraph()
# -----------
#
# Utility: Format paragraphs.
#
# ARGS:    None
#
# STDIN:   [ TODO DOCUMENT ME ]
#
# STDOUT:  Formatted paragraph.
#
# VARS:    [ TODO DOCUMENT ME ]
#
# DEPS:    sed tr tbl groff
#
# RETURN:  Unused
#
# USAGE EXAMPLE:
#
#   [ TODO DOCUMENT ME ]
#
function paragraph {
  SEPARATOR="" MARGIN="$(get MARGIN 3)" ROWSPACING=1 tableformat
}

# -------
# usage()
# -------
#
# Utility: Display program usage.
#
# ARGS:    None
#
# STDIN:   Unused
#
# STDOUT:  Usage message.
#
# VARS:    $PROGRAM: The program name as specified in $0 of the script.
#
#          $COMMANDS: Input, global list of commands.
#
# DEPS:    sed tr tbl groff
#
# RETURN:  Unused
#
# USAGE EXAMPLES:
#
#    usage; exit 0
#
function usage {
  unset helpdata
  for cmd in $COMMANDS; do
    helpdata+="$cmd|$($(ns $cmd _shorthelp))"$'\n'
  done
  echo -e "Usage: $PROGRAM [GLOBAL ARGUMENTS] COMMAND (COMMAND ARGUMENTS) [-- COMMAND (COMMAND ARGUMENTS)]...\n"
  FORMAT="llx" MARGIN="3" tableformat <<EOF
    GLOBAL ARGUMENTS
    _
    -y,--yes       | Automatically answer \"y\" to yes/no questions and \
                     accept the default value for other types of questions. \
                     Does not work for all commands.
    -a,--ascii     | If your terminal is displaying odd characters when \
                     running \`$PROGRAM\` it may not support utf8, try this.
    COMMANDS
    _
    $helpdata
    help [COMMAND] | Display help for a specific command.
EOF
  [[ -n "$1" ]] && echo "ERROR: $1."
}

# --------------------
# fatal(...)
# --------------------
#
# Utility: print an fatal and exit
#
# ARGS:  - ...: Messages to display regarding what went wrong.
#
# STDIN:   Unused
#
# STDOUT:  Usage message.
#
# VARS:    $EXITCODE: Code to exit with. Default is 1.
#
# DEPS:    sed tr tbl groff
#
# RETURN:  Unused
#
# USAGE EXAMPLES:
#
#    fatal "Something went wrong! (details ...)"
#
function fatal {
  exitcode=$(get EXITCODE 1)
  echo -e "$*" | MARGIN="0" paragraph > /dev/stderr
  exit $exitcode
}

# ------------------------
# longhelp(command, usage)
# ------------------------
#
# Utility: Format command specific help.
#
# ARGS:  - command: Command we're giving long help for.
#
#        - usage: Usage string.
#
# STDIN:   Detailed help text.
#
# STDOUT:  Formatted help message.
#
# VARS:    None
#
# DEPS:    sed tr tbl groff
#
# RETURN:  Unused
#
# USAGE EXAMPLES:
#
#   longhelp $1 "$PROGRAM delserver [SERVERNAME]" <<EOL
#     Delete a server by alias.
#   EOL
#
function longhelp {

  command="$1"
  shift

  while [ -n "$1" ]; do
    echo "$1" | sed 's/^/   /'
    shift
  done

  echo
  FORMAT="lw8lx" HEADER_FORMAT="lb" tableformat <<EOF
    Synopsis
    _
    Command: | $command
    Summary: | $($(ns $command _shorthelp))
EOF

  echo
  # TODO cat below isn't working right, or tableformat isn't normalizing space
  # right. Also TODO, add a table debugging program switch.
  FORMAT="lx" HEADER_FORMAT="lb" tableformat <<EOF
    Details
    _
    `cat`
EOF

}

# TODO docs!
# argshelp(command, usage)
function argshelp {
  command="$1"
  shift
  config=$(ns $command _CONFIG)
  config="${!config}"
  unset helplines
  while read_array a; do
    [ -z "${a[4]}" ] && [ -z "${a[5]}" ] && continue
    [ -n "${a[4]}" ] && helplines+="${a[4]}"
    [ -n "${a[4]}" ] && [ -n "${a[5]}" ] && helplines+=","
    [ -n "${a[5]}" ] && helplines+="${a[5]}"
    helplines+="|${a[6]}"$'\n'
  done <<< "$config"
  while [ -n "$1" ]; do
    echo "$1" | sed 's/^/   /'
    shift
  done
  echo
  FORMAT="lw18 lx" HEADER_FORMAT="lb" tableformat <<EOF
    Arguments
    _
    $helplines
EOF
  longhelp "$command"
}

# ------------------------
# valid_command(command)
# ------------------------
#
# Utility: Test if given command is NOT in the command list.
#
# ARGS:  - command: Command to test for.
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    $COMMANDS: Input, global list of commands.
#
# RETURN:  0 if the command is valid, 1 otherwise (bash `if` compatible).
#
# USAGE EXAMPLES:
#
#   if ! valid_command $COMMAND; then
#     usage "Unknown command \"$COMMAND\""; exit -2;
#   fi
#
function valid_command {
  [[ "$COMMANDS" =~ (^| )"$1"($| ) ]]
  return $?
}

# -------------------------
# valid_number(min, max, n)
# -------------------------
#
# Utility: Check if a number is valid and in a given range.
#
# ARGS:  - min: Minimum value.
#
#        - max: Maximum value.
#
#        - n: String to test.
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    None
#
# RETURN:  0 if the number is valid, 1 otherwise (bash `if` compatible).
#
function valid_number {
  [[ -n "$3" ]] && \
    [[ "$3" =~ ^[0-9]+$ ]] && \
    [[ $3 -ge $1 ]] && \
    [[ $3 -lt $2 ]] && \
    return 0
  return 1
}

#------------------------------------------------------------------------------
# UI: basic prompts
#------------------------------------------------------------------------------

# -------------------------------
# prompt(resultvar, message, ...)
# -------------------------------
#
# Utility: Similar to the bash built-in `read` function.
#
# Note this function DOES NOT implement the promptfn interface of multiprompt.
# It is a lower level utility and promptfn implementations can be build using
# this as a utility.
#
# ARGS:  - resultvar: Variable to store user input result.
#
#        - message: Prompt message.
#
#        - ...: Remaining arguments contain valid values. If additional
#          args are given, the user input is required to conform. If no
#          additional arguments are given, the input is unconstrained and
#          may be empty.
#
# STDIN:   Read user input.
#
# STDOUT:  Prompt message.
#
# VARS:    ${!resultvar} [OUT]: Output variable set to user input.
#
#          $DEFAULT [IN]: Value to pass as default to read.
#
#          $SILENT [IN]: Set to any nonempty value to use silent mode.
#
# RETURN:  Unused
#
# USAGE EXAMPLES:
#
#   prompt name "What's your name?"
#   echo "Well hello, ${name}."
#
#   prompt ynresult "Do you like fruit? (y/n)" "y" "n"
#   [[ $ynresult = y ]] && echo "Great, fruit is good for you." \
#      || echo "You really should get out more often."
#
function prompt {
  # TODO better result regex handling? do we need it? and docs for it.
  resultvar=$1
  message=$2
  shift; shift
  result=""
  [ -n "${SILENT}" ] && silent="-s" || silent=""
  [ -n "${DEFAULT}" ] && default="-i${DEFAULT}" || default=""
  if [[ -n "$*" ]]; then
    while [[ ! "$@" =~ (^| )"$result"($| ) ]]; do
      read ${silent} ${default} -ep "$message: " result < ${TTY} >> ${TTY}
    done
  else
    read ${silent} ${default} -ep "$message: " result < ${TTY} >> ${TTY}
  fi
  [ -n "${SILENT}" ] && echo
  export $resultvar="$result"
}

# -------------------------------------
# ynprompt(resultvar, message, default)
# -------------------------------------
#
# Utility: Standard yes/no prompt.
#
# Implements the promptfn interface for multiprompt.
#
# See multiprompt() / STDIN / [column 1] promptfn for details.
#
# ARGS:  - resultvar: Variable to store user input result.
#
#        - message: Prompt message.
#
#        - default: Optional default value if user presses [ENTER].
#
# STDIN:   Read user input.
#
# STDOUT:  Prompt message.
#
# VARS:    ${!resultvar}: Output variable set to user input.
#
# RETURN:  0 if the user selected 'y', 1 otherwise (bash `if` compatible).
#
# USAGE EXAMPLES:
#
#   ynprompt ynresult "Do you like fruit?"
#   [[ $ynresult = y ]] && echo "Great, fruit is good for you." \
#      || echo "You really should get out more often."
#
function ynprompt {
  echo
  [ -n "${3}" ] &&
    DEFAULT="${3}" prompt ynresult "${2} (y/n)" "y" "n" ||
    prompt ynresult "${2} (y/n)" "y" "n"
  export $1=$ynresult
  [ "${ynresult}" = "y" ]
}

# TODO documentation.
function textprompt {
  echo
  f="${1}"
  v="${!f}"
  IFS="^?" DEFAULT="${v}" prompt v "${2}"
  [ -n "${v}" ] && export $1="${v}"
}

# TODO documentation.
function pwprompt {
  echo
  while : ; do
    SILENT="1" prompt prompt1 "${2}"
    SILENT="1" prompt prompt2 "${2} (again)"
    [ "$prompt1" = "$prompt2" ] &&
      break ||
      echo "Passwords do not match, please try again."
  done
  export $1="${prompt1}"
}

# -----------------------
# read_filtered(variable)
# -----------------------
#
# Utility: A wrapper around bash's built-in read with a few extra features:
#
#  * Removes lines that contain only a comment.
#  * Removes empty lines.
#  * Removes comments from the end of lines.
#  * Trims extra whitespace from the start and end of lines.
#
# ARGS:  - variable: Name of variable to set with the read results.
#
# STDIN:   Stream of line(s) to read.
#
# STDOUT:  Unused
#
# VARS:  - ${!variable}: Output variable set to line that was read.
#
#        - $PREPROCESS: Input - Name of a function to call to rewrite valid
#          lines. PREPROCESS(line). If specified, function should `echo` the
#          altered line.
#
#        - $PREFIX: Input - Text to insert before valid input lines. Alternate
#          way to do similar as PREPROCESS without writing a separate function.
#
# RETURN:  Similar to bash build-in read function: zero on success, non-zero
#          value on error or EOF.
#
# USAGE EXAMPLES:
#
#   TODO
#
function read_filtered {
  export $1=""
  while : ; do
    read -r line
    rval=$?
    # Handle EOF.
    [[ $rval != 0 ]] && break
    # Remove comment lines.
    [[ -z "`grep -ve \"^[\s]*#\" <<< \"$line\"`" ]] && continue
    # Remove empty lines.
    [[ -z $line ]] && continue
    # End of line comments.
    line="`sed "s/\#[^$]*$//g" <<< \"$line\"`"
    # Trim whitespace at start and end.
    line="`sed \"s/^\s+//g\" <<< "$line" | sed \"s/\s+$//g\"`"
    [[ -n "$PREPROCESS" ]] && line=`$PREPROCESS "$line"`
    [[ -n "$PREFIX" ]] && line="$PREFIX $line"
    export $1="$line"
    break
  done
  # Return value from read call.
  return $rval
}

# --------------------
# read_array(variable)
# --------------------
#
# Utility: Similar to read_filtered but reads data into an array of values.
#
# ARGS:  - variable: Name of variable to set with array results.
#
# STDIN:   Stream of line(s) to read.
#
# STDOUT:  Unused
#
# VARS:  - ${!variable}: Output variable to hold array result.
#
#        - $PREPROCESS: Input - Name of a function to call to rewrite valid
#          lines. PREPROCESS(line). If specified, function should `echo` the
#          altered line.
#
#        - $PREFIX: Input - Text to insert before valid input lines. Alternate
#          way to do similar as PREPROCESS without writing a separate function.
#
#        - $SEPARATOR: Input - Column separator that delineates array items.
#          Default if not specified is "|".
#
# RETURN:  Similar to bash build-in read function: zero on success, non-zero
#          value on error or EOF.
#
# USAGE EXAMPLES:
#
#   TODO
#
function read_array {
  variable="$1"
  [[ -n "$SEPARATOR" ]] && sep="$SEPARATOR" || sep="|"
  # Based on read_filtered.
  read_filtered line
  rval=$?
  # Handle EOF.
  [[ $rval != 0 ]] && return $rval
  # Trim whitespace around separator.
  line="`sed \"s/\s*$sep\s*/$sep/g\" <<< \"$line\"`"
  # Parse array.
  IFS="$sep" read -a "$variable" <<< "$line"
  # Return value from read_filtered call.
  return $rval
}

# ---------------------------------------------
# display(fieldname, label, prompt_message)
# ---------------------------------------------
#
# Standard default displayfn() implementation for multiprompt.
#
# See multiprompt() / STDIN / [column 2] displayfn for details.
#
# ARGS:  - fieldname: Name of field.
#
#        - label: Label for use in list display function.
#
#        - prompt_message: The prompt message.
#
# STDIN:   Unused
#
# STDOUT:  Display "FIELDNAME: VALUE" or "FIELDNAME" if value not set.
#
# VARS:    None
#
# RETURN:  Unused
#
function display {
  [ -n "${!1}" ] && echo "${2}: ${!1}" || echo "${2}"
}

# -------------------------------
# multiprompt(title, num_columns)
# -------------------------------
#
# Display a menu of choices to user, enabling them to change value by number.
# How list items are displayed and how the data is collected from the user are
# controlled by the field data descibed below in STDIN.
#
#                        ----- TODO NEEDS REVIEW AND UPDATE -----
#
# ARGS:  - title: Text to show above the option listing.
#
#        - num_columns: Number of columns in the listing. Optional. Default=3.
#
# STDIN:   Rows of field records. Columns are separated with "|" by default
#          and rows are separated with a newline character. Lines starting with
#          a '#' character are ignored. Empty lines are ignored. Comments at
#          the end of line starting with '#' and continuing to end of line are
#          removed. Data table format:
#
#              [column 1] promptfn
#              -------------------
#              SIG:  promptfn(fieldname, prompt_message, label)
#              VARS: fields (array), labels (array), promptfns (array),
#                    displayfns (array), promptmessages (array),
#                    i (selected index).
#              Prompt function called to change an item value. This function
#              should ask for user input if needed and export the field value.
#
#              [column 2] displayfn
#              --------------------
#              SIG:  displayfn(fieldname, label, prompt_message)
#              VARS: fields (array), labels (array), promptfns (array),
#                    displayfns (array), promptmessages (array),
#                    i (selected index).
#              Display function should `echo` the item for display in list
#              mode. Keep the text short to work with the given # columns.
#
#              [column 3] default
#              ------------------
#              Default value for the field. It will only be applied if the
#              variable of the field doesn't already contain a value.
#
#              [column 4] fieldname
#              --------------------
#              Name of the field. Must be a single word name, it is used as
#              bash variable name.
#
#              [column 5] label
#              ----------------
#              Short label for the field. Normally used in list mode, `echo`d
#              by the displayfn.
#
#              [column 6] promptmessage
#              ------------------------
#              Message to display when prompting for a value. Normally used
#              in prompt mode, `echo`'d by the promptfn.
#
#              [column 7] visibility
#              ---------------------
#              TODO
#
# STDOUT:  Interactive.
#
# VARS:  - Each field is exported as a variable with the user configured value.
#
#        - $fields: Output array of field names that were processed.
#
#        - $labels: Output array of labels corresponding to the fields list.
#
#        - $INIT: Input - specify a function to run after parsing STDIN data
#          but before displaying list for the first time. Init functions have
#          access to the following vars: fields (array), labels (array),
#          promptfns (array), displayfns (array), promptmessages (array).
#
#        - $PREPROCESS: Input - Name of a function to call to rewrite valid
#          lines. PREPROCESS(line). If specified, function should `echo` the
#          altered line.
#
#        - $PREFIX: Input - Text to insert before valid input lines. Alternate
#          way to do similar as PREPROCESS without writing a separate function.
#
#        - $PROMPT: Input - Message displayed during item selection. Default
#          is "Choose item or press [ENTER] to confirm"
#
#        - $SEPARATOR: Input - Column separator that delineates array items.
#          Default if not specified is "|".
#
# RETURN:  Unused
#
# USAGE EXAMPLE:
#
#  multiprompt "Fruity multiprompt" 4 <<EOF
#    # promptfn | displayfn   | dflt | fieldname | label    | promptmessage
#    # ---------+-------------+------+-----------+----------+-----------------
#      ynprompt | cboxdisplay | n    | cherries  | Cherries | Include cherries
#      ynprompt | cboxdisplay | n    | oranges   | Oranges  | Include oranges
#      ynprompt | cboxdisplay | n    | pears     | Pears    | Include pears
#      ynprompt | cboxdisplay | y    | lemons    | Lemons   | Include lemons
#      ynprompt | cboxdisplay | n    | limes     | Limes    | Include limes
#  EOF
#  for f in ${fields[@]}; do echo "$f: ${!f}"; done
#
# Note that this is a contrived example showing the features of multiprompt().
# See checkboxprompt or radioprompt for a better way to handle single on/off
# values and for examples how to extend this function with a simpler interface.
#
# See STDIN above for column definitions.
#
function multiprompt {

  local -a multiprompt_fields
  local -a multiprompt_labels
  local -a multiprompt_promptfns
  local -a multiprompt_displayfns
  local -a multiprompt_promptmsgs
  local -a multiprompt_groups
  local -a multiprompt_predicates
  local pmsg="$(get PROMPT 'Choose item or [ENTER] to confirm')"

  local n=1
  while read_array a; do
    multiprompt_promptfns[$n]="${a[0]}"
    multiprompt_displayfns[$n]="${a[1]}"
    multiprompt_fields[$n]="${a[3]}"
    multiprompt_labels[$n]="${a[4]}"
    multiprompt_promptmsgs[$n]="${a[5]}"
    # Prepare for awk by replacing "]\s*[" with "|" and removing "\s*" before the first "[".
    multiprompt_groups[$n]="$(sed "s/[[:space:]]*\\([^\\[[:space:]]*\\)[^$]*$/\\1/g" <<< "${a[6]}")"
    multiprompt_predicates[$n]="$(sed 's/\][[:space:]]*\[/|/g' <<< "${a[6]}" | sed 's/[[:space:]]*\[/\[/g')"
    if [[ -z "${!a[3]}" ]]; then # Value not already set.
      if [[ "${a[2]}" = "=PROMPT" ]]; then
        # Magic value "=PROMPT" so promp user now.
        ${a[0]} "${a[3]}" "${a[5]}" "${a[4]}" < "${TTY}"
      else
        # Otherwise just set the default value.
        export ${a[3]}="${a[2]}"
      fi
    fi
    n=$((n+1))
  done

  [[ -n "${INIT}" ]] && ${INIT}
  while : ; do
    local n=1
    valid_number 1 64 ${2} && ncolumns=${2} || ncolumns=3
    local table=""
    local -a selectmap
    for i in "${!multiprompt_fields[@]}"; do
      local field="${multiprompt_fields[$i]}"
      #echo "group check '${multiprompt_groups[$i]}' ~= '${GROUP}' (in field ${field})"
      [ "${multiprompt_groups[$i]}" != "${GROUP}" ] && continue
      local j=2
      while : ; do
        local predicate="$(awk -F"[\\\\]|\\\\[|\\\\|]+" "{print \$${j}}" <<< "${multiprompt_predicates[$i]}")"
        [ -z "${predicate}" ] && break
        local testfield="$(sed 's/[[:space:]]*\([^\=[:space:]]*\)\=[^$]*/\1/g' <<< ${predicate})"
        local testvalue="$(sed 's/[^\=]*\=\([^$]*\)/\1/g' <<< ${predicate})"
        #echo "predicate check: '${!testfield}' ~= '${testvalue}' (in field ${field}, predicate field ${testfield})"
        [ "${!testfield}" != "${testvalue}" ] && continue 2
        j=$((j+1))
      done
      local displayfn="${multiprompt_displayfns[$i]}"
      local label="${multiprompt_labels[$i]}"
      local promptmsg="${multiprompt_promptmsgs[$i]}"
      local display="$(${displayfn} ${field} "${label}" "${promptmsg}")"
      table+="|`printf \"%3s %s\" \"${n}.\" \"${display}\"`"
      [ $(($n % ${ncolumns})) = 0 ] && table+=$'\n'
      selectmap[$n]="$i"
      n=$((n+1))
    done
    printf $'\n%s:\n\n' "${1}" >> "${TTY}"
    column -t -s "|" <<< "$table" >> "${TTY}"
    echo >> "${TTY}"; prompt i "${pmsg}" <"${TTY}" >> "${TTY}"
    [[ -z "$i" ]] && break # [ENTER] exits the loop
    selected="${selectmap[$i]}"
    if [ -z "${selected}" ]; then
      echo >> "${TTY}"
      echo "Sorry I don't understand \"$i\". Please select one of the" \
           "displayed items or press [ENTER] to confirm." >> "${TTY}"
      continue
    fi
    # Execute prompt function in a subshell so if we recurse back to
    # multiprompt the locals here are not affected.
    local field="${multiprompt_fields[$selected]}"
    local label="${multiprompt_labels[$selected]}"
    local promptfn="${multiprompt_promptfns[$selected]}"
    local promptmsg="${multiprompt_promptmsgs[$selected]}"
    local savedgroup="${GROUP}" # Stash the group, promptfn might change it.
    ${promptfn} "${field}" "${promptmsg}" "${label}" <"${TTY}" >>"${TTY}"
    local promptresult=$?
    GROUP="${savedgroup}"
    [ ${promptresult} = 0 ] || return ${promptresult}
  done
  fields=${multiprompt_fields[@]}
  labels=${multiprompt_labels[@]}
}
# Hack, can't export globals so have to declare here and unset before using.
declare -a fields
declare -a labels

# ----------------------------------------
# recordsprompt(records, title, dislpayfn)
# ----------------------------------------
#
#                        ----- TODO COMPLETE DOCUMENTATION -----
#
# VARS:  - $RECORDPROMPT
#
#        - $PROMPT
#
#        - $TITLE
#
#        - $ADDFN addfn(records, keys, promptlabel)
#
#        - $DELFN delfn(records, key, promptlabel)
#
# USAGE EXAMPLE:
#
#  # Shows a list of all selected fruits in a fruit record.
#  function fruit_display {
#    local -r records="$1"
#    local -r key="$2"
#    local -r fields=( $3 )
#    local -a fruits
#    for i in ${!fields[@]}; do
#      local field="${records}_${key}_${fields[$i]}"
#      [ "${!field}" = "y" ] && fruits[${#fruits[@]}]="${recordsprompt_labels[$i]}"
#    done
#    [ ${#fruits[@]} -gt 0 ] && printf "%s " "${fruits[@]}" || printf "[NO FRUITS]"
#  }
#
#  fruit_0_cherries=y
#  fruit_0_oranges=y
#  fruit_1_lemons=n
#  fruit_1_limes=y
#  recordsprompt fruit "fruit" fruit_display <<EOF
#    cboxprompt | cboxdisplay | n | cherries | Cherries
#    cboxprompt | cboxdisplay | n | oranges  | Oranges
#    cboxprompt | cboxdisplay | n | pears    | Pears
#    cboxprompt | cboxdisplay | y | lemons   | Lemons
#    cboxprompt | cboxdisplay | n | limes    | Limes
#  EOF
#
function recordsprompt {

  # Local vars.
  local -r recordsfield="$1"
  local -r recordslabel="$2"
  local -r recorddisplayfn="$3"
  local -r addfn=$(get ADDFN recordsprompt_addfn)
  local -r delfn=$(get DELFN recordsprompt_delfn)
  local -r recordprompt="$(get RECORDPROMPT 'Choose item to edit or press [ENTER] to confirm')"
  local -r prompt="$(get PROMPT 'Choose a record to edit or press [ENTER] to confirm')"
  local -r title="$(get TITLE "Choose ${recordslabel} to edit or press [ENTER] to confirm")"

  # If we haven't read fields off the input stream yet, do so.
  if [ ${#recordsprompt_fields[@]} = 0 ]; then
    local -a recordsprompt_promptfns
    local -a recordsprompt_displayfns
    local -a recordsprompt_defaults
    local -a recordsprompt_fields
    local -a recordsprompt_labels
    local -a recordsprompt_promptlabels
    while IFS="|" read promptfn displayfn default field label promptlabel; do
      recordsprompt_promptfns[${#recordsprompt_promptfns[@]}]=${promptfn}
      recordsprompt_displayfns[${#recordsprompt_displayfns[@]}]=${displayfn}
      recordsprompt_defaults[${#recordsprompt_defaults[@]}]="$(sed 's/^[[:space:]]*//g' <<< "${default}" | sed 's/[[:space:]]*$//g')"
      recordsprompt_fields[${#recordsprompt_fields[@]}]=${field}
      recordsprompt_labels[${#recordsprompt_labels[@]}]="$(sed 's/^[[:space:]]*//g' <<< "${label}" | sed 's/[[:space:]]*$//g')"
      recordsprompt_promptlabels[${#recordsprompt_promptlabels[@]}]="$(sed 's/^[[:space:]]*//g' <<< "${promptlabel}" | sed 's/[[:space:]]*$//g')"
    done
  fi

  # Loop. If multiprompt returns with 1 we regenerate the menu.
  while : ; do

    local config=""
    local keys="$(recordskeys ${recordsfield})"

    # Prompt config: add records listings
    for k in ${keys}; do
      config+="recordsprompt_group_prompt|${recorddisplayfn}||${recordsfield}|${k}|${recordsprompt_fields[@]}|"$'\n'
    done

    # Prompt config: edit individual records
    for i in ${!recordsprompt_fields[@]}; do
      for k in ${keys}; do
        local field=$(ns ${recordsfield} _ ${k} _ ${recordsprompt_fields[$i]})
        config+="${recordsprompt_promptfns[$i]}|${recordsprompt_displayfns[$i]}|${recordsprompt_defaults[$i]}|${field}|${recordsprompt_labels[$i]}|${recordsprompt_promptlabels[$i]}|$k"$'\n'
      done
    done

    # Prompt config: "add new record" controls
    if [ -n "${addfn}" ]; then
      config+="recordsprompt_addfn_prompt|recordsprompt_addfn_display||${recordsfield}|${recordsprompt_fields[@]}|${keys}|"$'\n'
    fi

    # Prompt config: "delete record" controls
    if [ -n "${delfn}" ]; then
      for k in ${keys}; do
        config+="recordsprompt_delfn_prompt|recordsprompt_delfn_display||${recordsfield}|${recordsprompt_fields[@]}|${k}|${k}"$'\n'
      done
    fi

    # Prompt.
    PROMPT="${prompt}" multiprompt "${title}" "1" <<< "${config}"
    [ $? = 1 ] || return 1

  done
}

# ----------------------------
# recordsprompt_group_prompt()
# ----------------------------
# TODO: Document this.
#
function recordsprompt_group_prompt {
  GROUP="$3" PROMPT="${recordprompt}" recordsprompt \
    "${recordsfield}" "${recordslabel}" "${recorddisplayfn}" "${addfn}" "${delfn}"
}

# -----------------------------
# recordsprompt_addfn_display()
# -----------------------------
# TODO: Document this.
#
function recordsprompt_addfn_display {
  get ADDLABEL "Add new ${recordslabel}"
}

# -------------------------------------------------
# recordsprompt_addfn_prompt(records, keys, fields)
# -------------------------------------------------
# TODO: Document this.
#
function recordsprompt_addfn_prompt {
  local -r records="$1"
  recordsnextkey ${records}
  local -r nextkey=$?
  ${addfn} "${records}" "${nextkey}" "$3"
  return 1
}

# ------------------------------------------
# recordsprompt_addfn(records, keys, fields)
# ------------------------------------------
# TODO: Document this.
#
function recordsprompt_addfn {
  local -r records="$1"
  local -r nextkey="$2"
  local -r fields=( $3 )
  for i in ${!fields[@]}; do
    field="${records}_${nextkey}_${fields[$i]}"
    value="${recordsprompt_defaults[$i]}"
    export ${field}="${value}"
  done
}

# -----------------------------
# recordsprompt_delfn_display()
# -----------------------------
# TODO: Document this.
#
function recordsprompt_delfn_display {
  get DELLABEL "Remove ${recordslabel}"
}

# ------------------------------------------------
# recordsprompt_delfn_prompt(records, key, fields)
# ------------------------------------------------
# TODO: Document this.
#
function recordsprompt_delfn_prompt {
  ${delfn} "$1" "$2" "$3"
  return 2
}

# -----------------------------------------
# recordsprompt_delfn(records, key, fields)
# -----------------------------------------
# TODO: Document this.
#
function recordsprompt_delfn {
  local -r records="$1"
  local -r key="$2"
  local -r fields=( $3 )
  local -r display="$(${recorddisplayfn} "${records}" "${key}" "$3")"
  ynprompt v "Really delete ${recordslabel} \"${display}\"?"
  if [ "${v}" = "y" ]; then
    for i in ${!fields[@]}; do
      field="${records}_${key}_${fields[$i]}"
      unset ${field}
    done
  fi
}

# --------------------
# recordskeys(records)
# --------------------
# TODO: Document this.
#
function recordskeys {
  # TODO: Find a better way to filter out functions (and other non-record vars).
  set | grep "^${1}_" | grep -v '()' | sed "s/^${1}_\([^_]*\)_.*/\1/g" | uniq | sort | sed ':a;N;$!ba;s/\n/ /g'
}

# -----------------------
# recordsnextkey(records)
# -----------------------
# TODO: Document this.
#
function recordsnextkey {
  local n=0
  for k in $(recordskeys $1); do
    valid_number 0 99999999 "$k" && n=$(($k>=$n?$k+1:$n))
  done
  return $n
}

# ------------------------------
# argsprompt(title, num_columns)
# ------------------------------
#
# Display a menu of choices to user, enabling them to change value by number.
# How list items are displayed and how the data is collected from the user are
# controlled by the field data descibed below in STDIN.
#
#                        ----- TODO FIX THESE DOCS -----
#
# ARGS:  - title: Text to show above the option listing.
#
#        - num_columns: Number of columns in the listing. Optional. Default=3.
#
# STDIN:   Rows of field records. Columns are separated with "|" by default
#          and rows are separated with a newline character. Lines starting with
#          a '#' character are ignored. Empty lines are ignored. Comments at
#          the end of line starting with '#' and continuing to end of line are
#          removed. Data table format:
#
#              [column 0] fieldname
#              -------------------
#              Name of field used as variable name containing result.
#
#              [column 1] default
#              --------------------
#              Default value. May be one of the following special values:
#
#                =REQUIRED - Bail if value is not supplied on the command line.
#
#                =PROMPT - Prompt if value is not supplied on the command line.
#
#              [column 2] label
#              ----------------
#              Short legible label for the field.
#
#              [column 3] description
#              ------------------------
#              More detailed description displayed in help message.
#
# STDOUT:  Interactive.
#
# VARS:  - Each field is exported as a variable with the user configured value.
#
#        - $fields: Output array of field names that were processed.
#
#        - $labels: Output array of labels corresponding to the fields list.
#
#        - $INIT: Input - specify a function to run after parsing STDIN data
#          but before displaying list for the first time. Init functions have
#          access to the following vars: fields (array), labels (array),
#          promptfns (array), displayfns (array), promptmessages (array).
#
#        - $PREPROCESS: Input - Name of a function to call to rewrite valid
#          lines. PREPROCESS(line). If specified, function should `echo` the
#          altered line.
#
#        - $PREFIX: Input - Text to insert before valid input lines. Alternate
#          way to do similar as PREPROCESS without writing a separate function.
#
#        - $PROMPT: Input - Message displayed during item selection. Default
#          is "Choose item or press [ENTER] to confirm"
#
#        - $SEPARATOR: Input - Column separator that delineates array items.
#          Default if not specified is "|".
#
# RETURN:  Unused
#
# USAGE EXAMPLE:
#
#  multiprompt "Fruity multiprompt" 4 <<EOF
#    # promptfn | displayfn   | dflt | fieldname | label    | promptmessage
#    # ---------+-------------+------+-----------+----------+-----------------
#      ynprompt | cboxdisplay | n    | cherries  | Cherries | Include cherries
#      ynprompt | cboxdisplay | n    | oranges   | Oranges  | Include oranges
#      ynprompt | cboxdisplay | n    | pears     | Pears    | Include pears
#      ynprompt | cboxdisplay | y    | lemons    | Lemons   | Include lemons
#      ynprompt | cboxdisplay | n    | limes     | Limes    | Include limes
#  EOF
#  for f in ${fields[@]}; do echo "$f: ${!f}"; done
#
# Note that this is a contrived example showing the features of multiprompt().
# See checkboxprompt or radioprompt for a better way to handle single on/off
# values and for examples how to extend this function with a simpler interface.
#
# See STDIN above for column definitions.
#
function argsprompt {

  # Variables init.
  local exitearly=$(get EARLYEXIT $(get FORCE_YES, 0))
  local title="$1"; shift
  local num_columns="$1"; shift
  local promptfn=$(get PROMPTFN textprompt)
  local displayfn=$(get DISPLAYFN display)
  local pfn
  local dfn

  if [ -z "$GROUP" ]; then
    # Only declare these at the top group. When recursing, keep the values.
    local -a argsprompt_fields
    local -a argsprompt_defaults
    local -a argsprompt_required
    local -a argsprompt_labels
    local -a argsprompt_prompts
    local -a argsprompt_longopts
    local -a argsprompt_shortopts
    local -a argsprompt_visibility
    local -a argsprompt_promptfns
    local -a argsprompt_displayfns
  fi

  # Parse the config.
  local i=0
  while read_array a; do
    local field="${a[0]}"
    [ -n "${a[8]}" ] && pfn="${a[8]}" || pfn="${promptfn}"
    [ -n "${a[9]}" ] && dfn="${a[9]}" || dfn="${displayfn}"
    argsprompt_fields[$i]="${field}"
    local dflt="${a[1]}"
    case "${a[1]}" in
      "=GROUP")
        dflt=""
        [ -z "${a[8]}" ] && pfn="argsprompt_group_prompt"
      ;;
      "=PROMPT"|"=REQUIRED")
        argsprompt_required["${#argsprompt_required[@]}"]="${field}"
      ;;
      *)
        [ -z "${!a[0]}" ] && export ${a[0]}="${a[1]}"
      ;;
    esac
    argsprompt_defaults[$i]="${dflt}"
    argsprompt_labels[$i]="${a[2]}"
    argsprompt_prompts[$i]="${a[3]}"
    argsprompt_longopts[$i]="${a[4]}"
    argsprompt_shortopts[$i]="${a[5]}"
    argsprompt_visibility[$i]="${a[7]}"
    argsprompt_promptfns[$i]="$pfn"
    argsprompt_displayfns[$i]="$dfn"
    i=$((i+1))
  done

  # Parse arguments.
  while : ; do
    [[ -z "$1" ]] && break
    local i=0
    local handled=0
    while : ; do
      case "$1" in
        "${argsprompt_longopts[$i]}")
          export ${argsprompt_fields[$i]}=$2
          shift; shift
          handled=1
        ;;
        "${argsprompt_shortopts[$i]}")
          export ${argsprompt_fields[$i]}=$2
          shift; shift
          handled=2
        ;;
        ${argsprompt_longopts[$i]}=*)
          export ${argsprompt_fields[$i]}="`sed \"s/${argsprompt_longopts[$i]}=//g\" <<< \"$1\"`"
          shift
          handled=3
        ;;
        ${argsprompt_shortopts[$i]}=*)
          export ${argsprompt_fields[$i]}="`sed \"s/${argsprompt_shortopts[$i]}=//g\" <<< \"$1\"`"
          shift
          handled=4
        ;;
      esac
      i=$((i+1))
      [ $handled != 0 ] && break
      [ "$i" -ge "${#argsprompt_fields[@]}" ] && break
    done
    [ $handled = 0 ] && fatal "bad arg: '$1'" # TODO better error handling
  done

  # Check if we have all argsprompt_required fields.
  if [ $exitearly != 0 ]; then
    local hasrequired=1
    for field in "${argsprompt_required[@]}"; do
      if [ -n "${!field}" ]; then
        # Required field has a value, keep checking.
        continue
      else
        # Required field has no value, stop checking.
        hasrequired=0
        break
      fi
    done
    # Early exit if all argsprompt_required fields supplied and requested.
    [ $hasrequired = 1 ] && return 0
  fi

  # Build a multiprompt config for the current group.
  local argsprompt_mpconfig=""
  for i in "${!argsprompt_fields[@]}"; do
    argsprompt_mpconfig+="${argsprompt_promptfns[$i]}|"
    argsprompt_mpconfig+="${argsprompt_displayfns[$i]}|"
    argsprompt_mpconfig+="${argsprompt_defaults[$i]}|"
    argsprompt_mpconfig+="${argsprompt_fields[$i]}|"
    argsprompt_mpconfig+="${argsprompt_labels[$i]}|"
    argsprompt_mpconfig+="${argsprompt_prompts[$i]}|"
    argsprompt_mpconfig+="${argsprompt_visibility[$i]}|"
    argsprompt_mpconfig+=$'\n'
  done

  # Do multiprompt until all required values are supplied.
  while : ; do
    PREFIX="" PREPROCESS="" \
      multiprompt "${title}" "${num_columns}" <<< "$argsprompt_mpconfig"
    for field in "${argsprompt_required[@]}"; do
      [ -z "${!field}" ] && continue 2
    done
    break
  done

  fields=${argsprompt_fields[@]}
  labels=${argsprompt_labels[@]}
}

function argsprompt_group_prompt {
  GROUP="$1" PROMPT="$2" argsprompt "$3" 1 <<< ""
}

#------------------------------------------------------------------------------
# UI: checkboxes
#------------------------------------------------------------------------------

# --------------------
# cboxpreprocess(line)
# --------------------
#
# PREPROCESS() implementation used by checkboxprompt().
#
# See read_filtered() / VARS / PREPROCESS for details.
#
# ARGS:  - line: Line to preprocess.
#
# STDIN:   Unused
#
# STDOUT:  checkboxprompt overrides.
#
# VARS:    None
#
# RETURN:  Unused
#
function cboxpreprocess {
  echo "cboxprompt | cboxdisplay | $1 |"
}

# --------------------------------------------
# cboxprompt(fieldname, prompt_message, label)
# --------------------------------------------
#
# promptfn() implementation used by checkboxprompt().
#
# See multiprompt() / STDIN / [column 1] promptfn for details.
#
# ARGS:  - fieldname: Name of field.
#
#        - prompt_message: The prompt message.
#
#        - label: Label for use in list display function.
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    None
#
# RETURN:  Unused
#
function cboxprompt {
  # Don't bother with input, just toggle the state.
  [[ "${!1}" = "y" ]] && export $1=n || export $1=y
}

# ---------------------------------------------
# cboxdisplay(fieldname, label, prompt_message)
# ---------------------------------------------
#
# displayfn() implementation used by checkboxprompt().
#
# See multiprompt() / STDIN / [column 2] displayfn for details.
#
# ARGS:  - fieldname: Name of field.
#
#        - label: Label for use in list display function.
#
#        - prompt_message: The prompt message.
#
# STDIN:   Unused
#
# STDOUT:  Display "LABEL=VALUE".
#
# VARS:    None
#
# RETURN:  Unused
#
function cboxdisplay {
  [[ "${!1}" = "y" ]] && echo "[X] ${2}" || echo "[ ] ${2}"
}

# ----------------------------------
# checkboxprompt(title, num_columns)
# ----------------------------------
#
# Simplified multiprompt that works with a group of related checkboxes. Upon
# completion, each supplied field will either have a value of 'y' or 'n'.
#
# ARGS:  - title: Text to show above the option listing.
#
#        - num_columns: Number of columns in the listing. Optional. Default=3.
#
# STDIN:   Rows of field records. Columns are separated with "|" by default
#          and rows are separated with a newline character. Lines starting with
#          a '#' character are ignored. Empty lines are ignored. Comments at
#          the end of line starting with '#' and continuing to end of line are
#          removed. Data table format:
#
#              [column 1] default
#              ------------------
#              Default value for the field. It will only be applied if the
#              variable of the field doesn't already contain a value. Must
#              contain value "y" or "n".
#
#              [column 2] fieldname
#              --------------------
#              Name of the field. Must be a single word name, it is used as
#              bash variable name.
#
#              [column 3] label
#              ----------------
#              Short label for the field. Used in list mode.
#
# STDOUT:  Interactive.
#
# VARS:  - Each field is exported as a variable set to 'y' or 'n'.
#
#        - $checked: Output array of all fields that were checked "on".
#
#        - $unchecked: Output array of all fields that were not checked "on".
#
#        - $fields: Output array of field names that were processed.
#
#        - $labels: Output array of labels corresponding to the fields array.
#
#        - $PROMPT: Input - Message displayed during item selection. Default is
#          "Toggle items by number or press [ENTER] to confirm"
#
#        - $SEPARATOR: Input - Column separator that delineates array items.
#          Default if not specified is "|".
#
# RETURN:  Unused
#
# USAGE EXAMPLE:
#
#   prompt name "What's your first name"
#   checkboxprompt "Choose Yoour Froots, $name" 3 <<EOF
#     # default |  fieldname    |  label
#     # -------------+----------+------------
#       n       |  cherries     |  Cherries
#       n       |  oranges      |  Oranges
#       n       |  blueberries  |  Blueberries
#       n       |  pears        |  Pears
#       y       |  lemons       |  Lemons
#       n       |  limes        |  Limes
#       n       |  grapes       |  Grapes
#       n       |  raspberries  |  Raspberries
#       n       |  mango        |  Mango
#       n       |  pomegranite  |  Pomegranite
#   EOF
#   [[ -z "$checked" ]] && checked="nothing!"
#   [[ -z "$unchecked" ]] && unchecked="nothing!"
#   echo "$name likes: $checked"
#   echo "$name hates: $unchecked"
#   echo "$name likes cherries? $cherries"
#
# See STDIN above for column definitions.
#
function checkboxprompt {
  [[ -n "$PROMPT" ]] && promptmsg="$PROMPT" || \
    promptmsg="Toggle items by number or press [ENTER] to confirm"
  PREPROCESS="cboxpreprocess" PROMPT="$promptmsg" multiprompt "$1" "$2"
  unset unchecked
  unset checked
  for f in "${multiprompt_fields[@]}"; do
    [[ "${!f}" = "y" ]] && checked+="$f " || unchecked+="$f "
  done
  export checked
  export unchecked
}

#------------------------------------------------------------------------------
# UI: radio buttons
#------------------------------------------------------------------------------

# -------------------
# radpreprocess(line)
# -------------------
#
# PREPROCESS() implementation used by radioprompt().
#
# See read_filtered() / VARS / PREPROCESS for details.
#
# ARGS:  - line: Line to preprocess.
#
# STDIN:   Unused
#
# STDOUT:  radioprompt overrides.
#
# VARS:    None
#
# RETURN:  Unused
function radpreprocess {
  echo "radprompt | raddisplay | | $1 |"
}

# ---------
# radinit()
# ---------
#
# INIT() implementation used by radioprompt().
#
# See multiprompt() / VARS / INIT for details.
#
# ARGS:    None
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:  - $selected_value: Value selected by the user.
#
#        - $selected_label: Label for the value selected by the user.
#
#        - $selected_index: Item selected by the user.
#
# RETURN:  Unused
#
function radinit {
  # Figure out the $selected_index using the $selected_value and fields array.
  n=1
  for field in "${multiprompt_fields[@]}"; do
    # If field value equals selected value, we found the $selected_index ($n).
    [ "${selected_value}" = "${field}" ] && break
    n=$((n+1))
  done
  if [[ ${#multiprompt_fields[@]} = $(($n-1)) ]]; then
    # There was no valid $selected_value so pick "1" and configure for it.
    n=1
    export selected_value="${multiprompt_fields[$n]}"
  fi
  export selected_index="$n"
  export selected_label="${multiprompt_labels[$n]}"
}

# -------------------------------------------
# radprompt(fieldname, prompt_message, label)
# -------------------------------------------
#
# promptfn() implementation used by radioprompt().
#
# See multiprompt() / STDIN / [column 1] promptfn for details.
#
# ARGS:  - fieldname: Name of field.
#
#        - prompt_message: The prompt message.
#
#        - label: Label for use in list display function.
#
# STDIN:   Unused
#
# STDOUT:  Display "LABEL=VALUE".
#
# VARS:  - $selected_value: Value selected by the user.
#
#        - $selected_label: Label for the value selected by the user.
#
#        - $selected_index: Item selected by the user.
#
# RETURN:  Unused
#
function radprompt {
  # Don't bother with input, just toggle the state.
  export selected_index="${i}" # $i = selected index
  export selected_value="${1}" # $1 = field name
  export selected_label="${labels[$selected_index]}"
}

# --------------------------------------------
# raddisplay(fieldname, label, prompt_message)
# --------------------------------------------
#
# displayfn() implementation used by radioprompt().
#
# See multiprompt() / STDIN / [column 2] displayfn for details.
#
# ARGS:  - fieldname: Name of field.
#
#        - label: Label for use in list display function.
#
#        - prompt_message: The prompt message.
#
# STDIN:   Unused
#
# STDOUT:  Display "LABEL=VALUE".
#
# VARS:    None
#
# RETURN:  Unused
#
function raddisplay {
  [[ "${selected_index}" = "${n}" ]] && echo "(*) ${2}" || echo "( ) ${2}"
}

# ----------------------------------------
# radioprompt(default, title, num_columns)
# ----------------------------------------
#
# Simplified multiprompt that works with a group of related checkboxes. Upon
# completion, each supplied field will either have a value of 'y' or 'n'.
#
# ARGS:  - default: Which option is selected by default. Must be a field in the
#          STDIN data or item #1 will be selected by default.
#
#        - title: Text to show above the option listing.
#
#        - num_columns: Number of columns in the listing. Optional. Default=3.
#
# STDIN:   Rows of field records. Columns are separated with "|" by default
#          and rows are separated with a newline character. Lines starting with
#          a '#' character are ignored. Empty lines are ignored. Comments at
#          the end of line starting with '#' and continuing to end of line are
#          removed. Data table format:
#
#              [column 1] default
#              ------------------
#              Default value for the field. It will only be applied if the
#              variable of the field doesn't already contain a value. Must
#              contain value "y" or "n".
#
#              [column 2] fieldname
#              --------------------
#              Name of the field. Must be a single word name, it is used as
#              bash variable name.
#
#              [column 3] label
#              ----------------
#              Short label for the field. Used in list mode.
#
# STDOUT:  Interactive.
#
# VARS:  - $selected_value: Value selected by the user.
#
#        - $selected_label: Label for the value selected by the user.
#
#        - $selected_index: Item selected by the user.
#
#        - $fields: Output array of field names that were processed.
#
#        - $labels: Output array of labels corresponding to the fields array.
#
#        - $PROMPT: Input - Message displayed during item selection. Default is
#          "Toggle items by number or press [ENTER] to confirm"
#
#        - $SEPARATOR: Input - Column separator that delineates array items.
#          Default if not specified is "|".
#
# RETURN:  Unused
#
# USAGE EXAMPLE:
#
#   radioprompt "raspberries" "Choose Yoour Froot" 3 <<EOF
#     # -------------+----------------------
#     # value        |   label
#     # -------------+----------------------
#       cherries     |   Cherries
#       oranges      |   Oranges
#       blueberries  |   Blueberries
#       pears        |   Pears
#       lemons       |   Lemons
#       limes        |   Limes
#   EOF
#   echo "You picked: $selected_label ($selected_value)"
#
# See STDIN above for column definitions.
#
function radioprompt {
  [[ -z "$3" ]] && ncolumns=3 || ncolumns="$3"
  [[ -n "$PROMPT" ]] && msg="$PROMPT" || \
    msg="Toggle items by number or press [ENTER] to confirm"
  export selected_value="$1"
  PREPROCESS="radpreprocess" INIT="radinit" PROMPT="$msg" \
    multiprompt "$2" "$ncolumns"
}


# Utility: Common initilization for the init[7|8]? commands.
function init_init {
  mkdir -p "$SCRIPTHOME"
  if [ ! -d "$SCRIPTHOME" ]; then
    echo "Could not create $SCRIPTHOME program directory."
    exit 1
  fi
  mkdir -p "$SCRIPTHOME/hooks"
  mkdir -p "$SCRIPTHOME/servers"
  mkdir -p "$SCRIPTHOME/settings"
  mkdir -p "$SCRIPTHOME/settings/modules"
  mkdir -p "$SCRIPTHOME/settings/themes"
  mkdir -p "$SCRIPTHOME/cache"
  [ -f "$SCRIPTHOME/cache/project.xml" ] || command_update
  return 0
}

# Utility: Check `sudo` access. Sets PREFLGHT_ERROR and returns a nonzero value
# if the access check failed.
function preflight_sudo {
  # TODO!
  PREFLGHT_ERROR=""
  return 1
}

#------------------------------------------------------------------------------
# SERVER COMMAND: ping
#------------------------------------------------------------------------------

function ping_preflight {
  return 0
}

function ping_command {
  uname -a
  return 0
}

#------------------------------------------------------------------------------
# SERVER COMMAND: apache2_init
#------------------------------------------------------------------------------

apache2_init_DEPS="apache2ctl a2ensite a2dissite a2enmod a2dismod"
package_Ubuntu_apache2ctl="apache2"
package_Ubuntu_a2ensite="apache2"
package_Ubuntu_a2dissite="apache2"
package_Ubuntu_a2enmod="apache2"
package_Ubuntu_a2dismod="apache2"

function apache2_init_preflight {
  echo "+INFO testing 123"
  if [ ! -d "$1" ]; then
    PREFLGHT_ERROR="Cannot read Apache2 config directory '$1'."
    return 1
  fi
  local -a sudo_missing
  for dep in ${apache2_init_DEPS}; do
    local varname="$(${AWK} '{print toupper($0)}' <<< "${dep}")"
    local line="$USER ALL = NOPASSWD:${!varname}"
    grep "${line}" /etc/sudoers || sudo_missing[${#sudo_missing[@]}]="${line}"
  done
  printf $'+INFO  - %s\n' "${sudo_missing[@]}"
  #if [ ${#sudo_missing[@]} > 0 ]; then
  #  # TODO print the sudo_missing list of lines.
  #  if ynprompt "Add these lines to /etc/sudoers?" < ${TTY} >> ${TTY}; then
  #    # TODO be more careful about existing sudoers.new if exists.
  #    local missing="$(printf $'%s\n' "${sudo_missing[@]}")"
  #    sed "/# User privilege specification/${missing}\n" /etc/sudoers |
  #      sudo ${TEE} /etc/sudoers.new < ${TTY} >> ${TTY}
  #  fi
  #fi
  return 0
}

function apache2_init_command {
  echo "+INFO testing 456"
  echo "$1"
  return 0
}


#------------------------------------------------------------------------------
# SERVER COMMAND: init_vhost
#------------------------------------------------------------------------------

function init_vhost_preflight {
  preflight_sudo || return 1
  return 0
}

function init_vhost_command {
  echo
}

#------------------------------------------------------------------------------
# USER COMMAND: init
#------------------------------------------------------------------------------

function init_shorthelp {
  echo "Alias for init7 currently. Will change to init8."
}

function init_help {
  help_init7
}

function init_command {
  init7 $@
}

#------------------------------------------------------------------------------
# USER COMMAND: init7
#------------------------------------------------------------------------------

function init7_shorthelp {
  echo "Create a Drupal 7 installation."
}

function init7_help {
  echo "TODO help_init7"
}

function init7_command {
  echo "init7 ARGS: $@"
  ERROR=`init_init`
  [ $? != 0 ] && fatal "Initialization error: $ERROR"
  sshcmd monkeysatkeyboards.com fletch init_vhost
}

#------------------------------------------------------------------------------
# USER COMMAND: init8
#------------------------------------------------------------------------------

function init8_shorthelp {
  echo "Create a Drupal 8 installation."
}

function init8_help {
  echo "TODO help_init8"
}

function init8_command {
  ERROR=`init_init`
  [ $? != 0 ] && fatal "Initialization error: $ERROR"
  echo "init8 ARGS: $@"
}

#------------------------------------------------------------------------------
# USER COMMAND: servers
#------------------------------------------------------------------------------

function servers_shorthelp {
  echo "List available servers."
}

function servers_help {
  echo "TODO help_servers"
}

function servers_command {
  ls "$SCRIPTHOME/servers" | sed 's/.server//g'
}

#------------------------------------------------------------------------------
# USER COMMAND: addserver
#------------------------------------------------------------------------------

read -d "" addserver_CONFIG <<EOF

  addserver_alias | =PROMPT | \
    Alias | Enter a short lowercase alias | \
    --alias | -a | A short aliased name for the host.

  addserver_roles | dtp | \
    Roles | | \
    --roles | -r | Role(s) the server will provide. Value can include one or \
                   more of [ldtp] which stand for (l)ocal (d)evelopment \
                   (t)testing and (p)roduction. It is not recommended to \
                   combine [l] with any other roles, doing so will cause a \
                   warning prompt to be displayed. | \
    | addserver_roles_prompt | addserver_roles_display

  addserver_host | =PROMPT | \
    Host | Enter the server's host name | \
    --host  | -h | Host name.

  addserver_user | $(get user =PROMPT) | \
    User | Enter the remote user name | \
    --user | -u | User name.

  addserver_identity | | \
    SSH identity file | Path to SSH .pem identity file. | \
    --identity-file | -i | SSH identity file path (optional).

  addserver_sshopts | | \
    SSH options | Additional SSH options. | \
    --ssh-options | -o | Additional SSH options (optional).

  addserver_database | =GROUP | \
    Database settings | Choose item to edit or press [ENTER] to return | | | | | \
    | addserver_database_display

  addserver_dbtype | mysql | \
    Database type | Database type | \
    --db-type | -d | Database type (currently only mysql). | \
    addserver_database | addserver_dbtype_prompt

  addserver_dbuser | =PROMPT | \
    Database user | Database user | \
    --db-user | -U | Database user with permission to create databases. | \
    addserver_database

  addserver_dbpass | | \
    Database password | Database password | \
    --db-password | -p | Database password. | \
    addserver_database | pwprompt

  addserver_httpd | =GROUP | \
    Web server settings | Choose item to edit or press [ENTER] to return | | | | | \
    | addserver_httpd_display

  addserver_httpdtype | apache2 | \
    Web server type | Web server type | \
    --httpd-type | -H | Web server type (currently only apache2). | \
    addserver_httpd | addserver_httpdtype_prompt

  addserver_apache2conf | /etc/apache2 | \
    Apache 2 configuration directory | Apache 2 configuration directory | \
    --apache2-conf | -c | Apache 2 configuration directory. | \
    addserver_httpd[addserver_httpdtype=apache2]

  addserver_apache2logs | /var/log/apache2 | \
    Apache 2 logs directory | Apache 2 logs directory | \
    --apache2-logs | -l | Apache 2 logs directory. | \
    addserver_httpd[addserver_httpdtype=apache2]

  addserver_apache2vhosts | | \
    Apache 2 virtual hosts config | Apache 2 virtual hosts config | \
    || Apache 2 virtual hosts config. | \
    addserver_httpd[addserver_httpdtype=apache2] | \
    addserver_apache2vhosts_prompt

EOF

# TODO: E-mail prompt for ServerAdmin.
read -d "" addserver_apache2vhosts_RECORD <<EOF
  cboxprompt | cboxdisplay |  n   | ssl   | Enable SSL
  textprompt | display     | *:80 | name  | NameVirtualHost | NameVirtualHost name (e.g. *:80)
  textprompt | display     |      | admin | ServerAdmin     | Server admin e-mail address
EOF

read -d "" addserver_roles_CHECKBOXES <<EOF
  n  |  addserver_roles_local       |  Local development
  y  |  addserver_roles_dev         |  Development server
  y  |  addserver_roles_testing     |  Testing server
  y  |  addserver_roles_production  |  Production server
EOF

function string_contains {
  grep "$2" <<< "$1" >> /dev/null
}

function addserver_roles_sanitize {
  local roles=""
  string_contains "${addserver_roles}" "l" && roles+=l
  string_contains "${addserver_roles}" "d" && roles+=d
  string_contains "${addserver_roles}" "t" && roles+=t
  string_contains "${addserver_roles}" "p" && roles+=p
  export addserver_roles="${roles}"
}

function addserver_roles_prompt {
  addserver_roles_sanitize
  local -r field="$1"
  local roles=""
  local addserver_roles_local=n
  local addserver_roles_dev=n
  local addserver_roles_testing=n
  local addserver_roles_production=n
  string_contains "${addserver_roles}" "l" && addserver_roles_local=y
  string_contains "${addserver_roles}" "d" && addserver_roles_dev=y
  string_contains "${addserver_roles}" "t" && addserver_roles_testing=y
  string_contains "${addserver_roles}" "p" && addserver_roles_production=y
  checkboxprompt "Select server roles" 2 <<< "${addserver_roles_CHECKBOXES}"
  [ "${addserver_roles_local}" = y ] && roles+="l"
  [ "${addserver_roles_dev}" = y ] && roles+="d"
  [ "${addserver_roles_testing}" = y ] && roles+="t"
  [ "${addserver_roles_production}" = y ] && roles+="p"
  export addserver_roles="${roles}"
}

function addserver_roles_display {
  addserver_roles_sanitize
  local -r roles=( ${addserver_roles} )
  local display=""
  for (( i=0; i<${#roles}; i++ )); do
    [ ${roles:$i:1} = l ] && display+="local "
    [ ${roles:$i:1} = d ] && display+="development "
    [ ${roles:$i:1} = t ] && display+="testing "
    [ ${roles:$i:1} = p ] && display+="production "
  done
  display="$(sed 's/[[:space:]]$//g' <<< "${display}" | sed 's/ /, /g')"
  printf "Roles: %s" "${display}"
}

function addserver_apache2vhosts_display {
  local -r records="$1"
  local -r key="$2"
  local -r namefield="${records}_${key}_name"
  local -r name="${!namefield}"
  echo "NameVirtualHost ${name}"
}

function addserver_apache2vhosts_prompt {
  GROUP="" \
  apache2vhosts_0_name="*:80" \
  apache2vhosts_0_ssl="n" \
  apache2vhosts_1_name="*:443" \
  apache2vhosts_1_ssl="y" \
    recordsprompt apache2vhosts "virtual host" \
    addserver_apache2vhosts_display <<< "${addserver_apache2vhosts_RECORD}"
  # TODO: there's a bug here, it's jumping up two menu levels after exit.
}

function addserver_httpdtype_prompt {
  local -r addserver_httpdtype_prompt_field="${1}"
  PROMPT="" radioprompt "${!addserver_httpdtype_prompt_field}" "$2" 3 <<EOF
    apache2 |   Apache 2
    nginx   |   Nginx
EOF
  export ${addserver_httpdtype_prompt_field}="${selected_value}"
}

function addserver_database_display {
  dbuser=$(get addserver_dbuser "[USER NOT SET]")
  [ -n "${addserver_dbpass}" ] &&
    dbpass="[PASSWORD SET]" ||
    dbpass="[NO PASSWORD]"
  echo "$2: ${addserver_dbtype} / ${dbuser} / ${dbpass}"
}

function addserver_httpd_display {
  echo "$2: ${addserver_httpdtype}"
}

function addserver_shorthelp {
  echo "Add a new server."
}

function addserver_help {
  argshelp $1 "$PROGRAM $1 (ARGUMENTS)" <<EOL
  TODO addserver help
EOL
}

function addserver_preflight {

  # Init ~/.ddo
  if ! init_init; then
    PREFLGHT_ERROR="Cannot initialize program directory $SCRIPTHOME."
    return 1
  fi

  # Test access to $SCRIPTHOME/servers
  f="$SCRIPTHOME/servers/TESTFILE"
  touch "$f"
  if [ -f "$f" ]; then
    rm -f "$f"
  else
    PREFLGHT_ERROR="Cannot write to servers directory $SCRIPTHOME/servers."
    return 1
  fi

  # Preflight passed.
  return 0
}

function addserver_command {

  # Process arguments.
  PROMPT="Choose item to edit or press [ENTER] to test access and save" \
    argsprompt "Add a new server" 1 "$@" <<< "${addserver_CONFIG}"

  # Check output file.
  file="$SCRIPTHOME/servers/${addserver_alias}.server"
  [ -f "$file" ] && fatal "Server file \"${addserver_alias}.server\" already exists, cowardly refusing to overwrite existing server configuration."

  # Write output file.
  for f in ${fields[@]}; do
    name=$(sed "s/addserver/${addserver_alias}/g" <<< ${f})
    echo "${name}=${!f}" >> "$file"
  done

  # Read output file and test.
  if ! loadserver "${addserver_alias}"; then
    rm -f "$file"
    fatal "Could not write server configuraion in $file."
  fi
  identity=$(get $(ns ${addserver_alias} _identity))
  user=$(get $(ns ${addserver_alias} _user))
  host=$(get $(ns ${addserver_alias} _host))
  opts=$(get $(ns ${addserver_alias} _sshopts))

  # Offer key exchange if the server is requiring a password.
  unset exchange_args
  if ssh_pw_required "${host}" "${user}" "${identity}" "${opts}"; then
    echo
    paragraph <<EOF
      The SSH command requires a password for user "${user}" at \
      host "${host}". It will ask for it quite often during normal \
      operations. If you wish, we can attempt a key exchange with the remote \
      server after which the password will not be required. Note that you can \
      skip this now and run \`${PROGRAM} keyexchange\` later to exchange keys.
EOF
    if ynprompt v "Exchange public key with host ${host}?"; then
      [ -f ~/.ssh/id_rsa.pub ] && exchange_args="-t rsa -s ${addserver_alias}"
      # TODO handle other key types.
    fi
  fi

  # Do key exchange if requested.
  if [ -n "$exchange_args" ]; then
    echo "Exchanging keys..."
    if exchange_results=$(keyexchange ${exchange_args}); then
      echo "${exchange_results}"
    else
      echo "Key exchange failed, sorry. Server said: ${exchange_results}."
      exchange_results="Failed: ${exchange_results}"
    fi
  else
    exchange_results="[NOT NEEDED]"
  fi

  # Test remote.
  echo
  printf "Testing remote access... "
  if remoteuname="$(remote "$addserver_alias" ping)"; then
    printf $'[OK]\n'
  else
    printf $'[ERROR]\n'
    rm -f "$file"
    fatal "Can't reach server, please check settings and try again."
  fi

  # Init remote.
  printf "Initialzing ${addserver_httpdtype} server... "
  case "${addserver_httpdtype}" in
    "apache2")
      remote "${addserver_alias}" apache2_init "${addserver_httpdconf}" &&
        printf "${result}"$' [OK]\n' || printf $'[ERROR]\n'
    ;;
    "nginx")
      # TODO nginx support.
    ;;
  esac

  # Report success.
  echo
  FORMAT="rblx" MARGIN="3" HEADER_FORMAT="lb" ROWSPACING="1" tableformat <<EOF
    Add new server
    _
    alias          | ${addserver_alias}
    user           | ${user}
    host           | ${host}
    system         | ${remoteuname}
    identity file  | $(get identity "[NOT SET]")
    options        | $(get opts "[NOT SET]")
    key exchange   | ${exchange_results}
EOF
  MARGIN="3" paragraph <<EOF
    _
    Connection to host ${host} with user ${user} is confirmed. Server with \
    alias "${addserver_alias}" was successfully configured.
    Note that user ${user}@${host} must have administrative privileges or \
    must be configured to use sudo.
EOF
# TODO note about what exact admin privs user needs above.
# TODO test apachectl access
}

#------------------------------------------------------------------------------
# SERVER COMMAND: keyexchange_rsa
#------------------------------------------------------------------------------

function keyexchange_rsa_command {

  # Parse the key.
  key="$1"
  [ -z "$key" ] && fatal "No key given."
  IFS=" " read type rsa id <<< "${key}"
  [ -z "$type" ] || [ -z "$rsa" ] || [ -z "$id" ] && fatal "Bad key format."

  # Append or write new key file.
  file="$(echo ~/.ssh/authorized_keys)"
  if [ -f "$file" ]; then
    if grep "$rsa" "$file" >> /dev/null; then
      # Key already in authorized_keys.
      echo "Key is already in file ${file}, skipping."
    else
      # Append the file.
      echo "${key}" >> "$file"
      [ grep "$rsa" "$file" >> /dev/null ] ||
        fatal "Could not append key to file ${file}."
    fi
  else
    # No existing file just write a new one.
    echo "${key}" > "$file"
    [ -f "$file" ] || fatal "Could not create file ${file}."
    echo "Created $file."
  fi
}

#------------------------------------------------------------------------------
# USER COMMAND: keyexchange
#------------------------------------------------------------------------------

read -d "" keyexchange_CONFIG << EOF

  keyexchange_type | =REQUIRED | \
    Type of key | Type of key | \
    --type | -t | Key type. Currently only 'rsa' is supported.

  keyexchange_server | =REQUIRED | \
    Server alias | Server alias | \
    --server | -s | Server alias.

  keyexchange_keyfile | $(echo ~/.ssh/id_rsa.pub) | \
    Key file | Key file | \
    --file | -f | Key file.

EOF

function keyexchange_shorthelp {
  echo "Exchange SSH keys with a server."
}

function keyexchange_help {
  argshelp $1 "$PROGRAM $1 (ARGUMENTS)" <<EOL
  TODO keyexchange help
EOL
}

# Workhorse function for keyexchange command, also utility used by addserver.
function keyexchange {

  # Process arguments.
  PROMPT="Choose item to edit or press [ENTER] to exchange keys" \
    argsprompt "Key exchange" 1 "$@" <<< "${keyexchange_CONFIG}"

  # Read key file.
  if [ ! -f "$keyexchange_keyfile" ]; then
    echo "Could not open key file ${keyexchange_keyfile}."
    return 1
  fi
  read key < "$keyexchange_keyfile"
  if [ -z "$key" ]; then
    echo "Could not read key from file ${keyexchange_keyfile}."
    return 2
  fi

  # Figure out which remote key exchange command to use.
  remotecmd="keyexchange_${keyexchange_type}"
  if ! func $(ns command_ ${remotecmd}); then
    echo "Sorry I don't understand key type '${keyexchange_type}'."
    return 3
  fi

  # Load server data.
  if ! loadserver "${keyexchange_server}"; then
    echo "Cannot load server \"${keyexchange_server}\"."
    return 4
  fi
  user=$(get $(ns ${keyexchange_server} _user))
  host=$(get $(ns ${keyexchange_server} _host))
  identity=$(get $(ns ${keyexchange_server} _identity))
  opts=$(get $(ns ${keyexchange_server} _sshopts))

  # Execute remote key exchange command.
  result=$(remote "${keyexchange_server}" "${remotecmd}" "${key}")
  if [ $? = 0 ]; then
    if ssh_pw_required "${host}" "${user}" "${identity}" "${opts}"; then
      [ -n "$result" ] &&
        echo "Reason unknown. Remote host said: \"$result\"." ||
        echo "Reason unknown."
      return 5
    else
      echo "$result"
      return 0
    fi
  else
    echo "$result"
    return 6
  fi
}

function keyexchange_command {
  result=$(keyexchange $@) &&
    echo "Key exchange success: $result" ||
    fatal "Key exchange failed: $result"
}

#------------------------------------------------------------------------------
# USER COMMAND: modserver
#------------------------------------------------------------------------------

function modserver_shorthelp {
  echo "Modify an existing server."
}

function modserver_help {
  echo "TODO help_modserver"
}

function modserver_command {
  echo "modserver ARGS: $@"
}

#------------------------------------------------------------------------------
# USER COMMAND: delserver
#------------------------------------------------------------------------------

function delserver_shorthelp {
  echo "Remove a server."
}

function delserver_help {
  longhelp $1 "$PROGRAM $1 [SERVERNAME]" <<EOL
  Delete a server by alias. TODO WILL THIS AFFECT EXISTING PROJECTS?
EOL
}

function delserver_command {
  echo "delserver ARGS: $@"
}

#------------------------------------------------------------------------------
# USER COMMAND: update
#------------------------------------------------------------------------------

function update_shorthelp {
  echo "Update Drupal project information from updates.drupal.org."
}

function update_help {
  echo "TODO help_update"
}

function __update_modules {
  type=$1
  vers=$2
  output=$3
  echo -n "Updating $vers ${type}s... "
  xmllint --shell "${SCRIPTHOME}/cache/project.xml" <<< "cat /projects/project/project_status[text()=\"published\"]/../type[text()=\"project_${type}\"]/../api_versions/api_version[text()=\"${vers}\"]/../../short_name/text()" | grep -v " -------" | grep -v "/ >" > "$output"
  echo `wc -l "$output" | sed "s/[^0-9]//g"` "found."
}

function _update_modules {
  __update_modules module 7.x "$SCRIPTHOME/cache/module-7.x"
  __update_modules theme 7.x "$SCRIPTHOME/cache/theme-7.x"
  __update_modules module 8.x "$SCRIPTHOME/cache/module-8.x"
  __update_modules theme 8.x "$SCRIPTHOME/cache/theme-8.x"
}
#_update_modules

function update_command {
  rm -f $SCRIPTHOME/cache/project.xml
  wget http://updates.drupal.org/release-history/project-list/all -O $SCRIPTHOME/cache/project.xml
  _update_modules
  echo "TODO update"
}

#------------------------------------------------------------------------------
# USER COMMAND: help
#------------------------------------------------------------------------------

help_DEPS="tr fmt"
package_Cygwin_tr="coreutils"
package_Cygwin_fmt="coreutils"

function help_shorthelp {
  echo "Display a help message."
}

function help_help {
  longhelp $1 "$PROGRAM $1" "$PROGRAM $1 [COMMAND]" <<EOL
  Yo dawg I heard you like help with your help. So I'm here to help.

  The 'drupal help' form of the command shows a list of commands and main
  program usage.

  The 'drupal help [COMMAND]' form displays help for a specified command.
EOL
}

function help_preflight {
  PREFLGHT_ERROR="This is an fatal."
  return 0
}

function help_command {
  if test -z "$1"; then
    usage
    exit 0
  else
    echo
    if ! valid_command "$1"; then
      usage "No help for unknown command \"$1\""; exit -3;
    fi
    $(ns $1 _help) $1
  fi
}

#------------------------------------------------------------------------------
# OS specific package management
#------------------------------------------------------------------------------

# Package manager function for Cygwin.
function package_Cygwin {
  echo " - Please use Cygwin setup.exe to install package \"$*\"."
}

# Package manager function for Ubuntu.
function package_Ubuntu {
  sudo apt-get install "$*"
}

#------------------------------------------------------------------------------
# Initialization.
#------------------------------------------------------------------------------

prog LSB_RELEASE lsb_release && OS="$(${LSB_RELEASE} -si)" || OS="$(uname -o)"

PM_INSTALL=$(ns package_ $OS)

# This and the -i switch in the hashbang at the top of the file are necessary
# to read COLUMNS shell var.
kill -s WINCH $$

# Parse arguments.
declare arguments=$(get REMOTE_ARGUMENTS)
[ -n "${REMOTE_ARGUMENTS}" ] &&
  arguments=( "${REMOTE_ARGUMENTS[@]}" ) ||
  arguments=( "$@" )

declare i=0
declare command
for argument in "${arguments[@]}"; do
  if [ "${argument}" = "--remote" ]; then
    REMOTE=1
  elif [ "${argument}" = "--" ]; then
    [ -n "$command" ] && commands[$i]="$command"
    i=$((i+1))
    unset command
  else
    [ -z "$command" ] && command="$argument" || command+=`printf " %q" "$argument"`
  fi
done
[ -n "$command" ] && commands[$i]="$command"
[ $REMOTE = 1 ] && COMMANDS="${SERVER_COMMANDS}" || COMMANDS="${USER_COMMANDS}"

# Check the commands.
for command_and_args in "${commands[@]}"; do
  acommand=($command_and_args)
  command="${acommand[0]}"
  if ! valid_command $command; then
    [[ -n "${invalid_commands[*]}" ]] && invalid_commands+=" "
    invalid_commands+=$command
  fi
done

# Collect deps.
declare deps="${DEPS}"
for command_and_args in "${commands[@]}"; do
  acommand=($command_and_args)
  command="${acommand[0]}"
  command_DEPS=$(ns $command _DEPS)
  if [ -n "${!command_DEPS}" ]; then
    [ -n "${deps}" ] && deps+=" "
    deps+="${!command_DEPS}"
  fi
done

# Find missing deps.
declare missing
for dep in "${deps[@]}"; do
  prog DEP $dep || missing+="$dep "
done

# Process missing deps.
if [ -n "$missing" ]; then

  echo -e "\nMissing tools..."

  # Gather info about the tool packages.
  unset packages
  for item in $missing; do
    package=$(ns package_ $OS _ $item)
    if [ -z "${!package}" ] || ! func ${PM_INSTALL}; then
      echo " - $item: no suggestion on how to install, sorry"
      continue
    fi
    packages+="${!package}"
  done

  # Run package manager.
  packages=`echo "$packages" | xargs -n1 | sort -u | xargs` # unique, sorted
  for package in $packages; do
    ${PM_INSTALL} ${package}
  done

  # Did that solve it?
  unset still_missing
  for item in $missing; do
    prog DEP $item || still_missing+="$item "
  done

  # Report.
  echo
  if [ -n "$still_missing" ]; then
    echo "Could not automatically resolve the following missing tools: $still_missing" ||
    exit 1
  else
    echo "Automatically resolved missing deps \"$missing\"."
  fi
fi

# Process deps.
prog _AWK awk # temp need for loop below.
for dep in ${deps}; do
  depname=`echo $dep | $_AWK '{print toupper($0)}'`
  prog $depname $dep
done
unset _AWK
unset missing

# Set up the temporary directory.
[ ! -d "$TEMPDIR" ] &&
  fatal "Could not create temporary directory, exiting."
echo "TESTVALUE" > "$TEMPDIR/writecheck"
[ -f "$TEMPDIR/writecheck" ] &&
  grep "TESTVALUE" "$TEMPDIR/writecheck" >> /dev/null &&
  rm "$TEMPDIR/writecheck" ||
  fatal "Could not write to temporary directory, exiting."

# Did we understand all the commands?
[ -z "$commands[*]" ] && fatal "No command given"
[ -n "${invalid_commands[*]}" ] && \
  fatal "Unknown command(s) \"$invalid_commands\". Try \`$PROGRAM help\`."

# UTF-8 autodetect
#if [ $REMOTE != 1 ]; then
#  CHARMAP=$(locale charmap)
#  if [ "${CHARMAP}" != "UTF-8" ]; then
#    echo
#    paragraph <<< "It looks like your terminal might not be configured to support UTF-8 characters. Would you like to use plain ASCII mode instead?"
#    ynprompt v "Press 'y' to continue in UTF-8 mode or 'n' to change to ASCII." y || OUTPUT_MODE="ascii"
#  fi
#fi

# Preflght checks.
for command_and_args in "${commands[@]}"; do
  read command args <<< "$command_and_args"
  preflightfns=( $(ns $command _preflight _ $OS) $(ns $command _preflight) )
  for preflightfn in ${preflightfns[@]}; do
    func ${preflightfn} || continue
    unset PREFLGHT_ERROR
    ${preflightfn} ${args}
    result=$?
    flightcheck=$(( $flightcheck | $result ))
    [[ $result ]] && [[ -n "$PREFLGHT_ERROR" ]] && PREFLIGHT_ERRORS[${#PREFLIGHT_ERRORS[@]}]="$PREFLGHT_ERROR"
    [[ $result ]] && [[ -n "$PREFLIGHT_WARNING" ]] && PREFLIGHT_WARNINGS[${#PREFLIGHT_WARNINGS[@]}]="$PREFLIGHT_WARNING"
    break; # Only invoke 1 version of preflight func.
  done
done
if [[ $flightcheck != 0 ]]; then
  echo "${PREFLIGHT_ERRORS[*]}"
  fatal "Did not pass preflight checks: ${PREFLIGHT_ERRORS[*]}" # TODO list ERRORs
fi

# Main.
for command_and_args in "${commands[@]}"; do
  read command args <<< "$command_and_args"
  commandfns=( $(ns $command _command _ $OS) $(ns $command _command) )
  for commandfn in ${commandfns[@]}; do
    func ${commandfn} || continue
    ${commandfn} ${args}
    break; # Only invoke 1 version of command func.
  done
done
