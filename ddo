#!/bin/bash -i

# TODO: general script header docs

# TODO: developer documentation: command and preflight function patterns.

declare -r SCRIPTHOME="$HOME/.ddo"
declare -r SCRIPTPATH=$0
declare -r PROGRAM=$(basename ${0})
declare -r TTY="$(tty)"
declare -r USER_COMMANDS="init init7 init8 servers addserver modserver delserver update help keyexchange"
declare -r SERVER_COMMANDS="ping init_vhost keyexchange_remote apache2_init mysql_scan"
declare -r DEPS="dd od tee cat ssh awk grep sed wget git tbl groff tr"
declare -r TEMPDIR="$(mktemp -d /tmp/ddo.XXXXXXXXXX)"
trap 'rm -rf "$TEMPDIR"' EXIT INT TERM HUP

declare user
[ -n "$USERNAME" ] && user="$USERNAME"
[ -n "$USER" ] && user="$USER"

#------------------------------------------------------------------------------
# Utilities
#------------------------------------------------------------------------------

# ---------------------
# get(varname, default)
# ---------------------
#
# Utility: Syntax sugar to read variable and supply a default if it is not set.
#
# ARGS:  - varname: Variable name.
#
#        - default: Default value if ${!varname} is not set.
#
# STDIN:   Unused
#
# STDOUT:  Variable value or default.
#
# VARS:    None
#
# DEPS:    None
#
# RETURN:  Unused (always resolves true).
#
# USAGE EXAMPLE:
#
#   unset VAR
#   var=$(get VAR "default value")
#   echo $var # "default value"
#   VAR="my value"
#   var=$(get VAR "default value")
#   echo $var # "my value"
#
function get {
  var="$1"
  [ -n "${!var}" ] && echo "${!var}" || echo "$2"
}

# ----------------------
# repeat(ntimes, string)
# ----------------------
#
# Utility: Repeat a string some specified number of times. To preserve
# whitespace in output, quote the call: "$(repeat 5 ' hi ')".
#
# ARGS:  - ntimes: How many times to repeat the string. Must be an integer
#                  value greater than zero.
#
#        - string: String to repeat.
#
# STDIN:   Unused
#
# STDOUT:  Repeated string.
#
# VARS:    None
#
# DEPS:    None
#
# RETURN:  Unused (always resolves true).
#
# USAGE EXAMPLE:
#
#   repeat 5 "hello"        # "hellohellohellohellohello"
#   repeat 5 "hello  "      # "hello hello hello hello hello"
#   "$(repeat 5 'hello  ')" # "hello  hello  hello  hello  hello  "
#
function repeat {
  # TODO: validate that $1 is an integer and is >= 0.
  [ "$2" = $'\n' ] && v=$'\n ' || v="$2"
  unset str
  for i in $(seq 1 $1); do
    str+="$v"
  done
  printf '%b' "$str"
}

# ------------------
# loadserver(server)
# ------------------
#
# Utility: Load server settings.
#
# ARGS:  - server: Server alias.
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    ${!server}_alias: Server alias.
#          ${!server}_host: Server host.
#          ${!server}_user: Server user.
#          ${!server}_identity: Server identity.
#          ${!server}_options: Server options.
#
# DEPS:    None
#
# RETURN:  0 if data successfully loaded, 1 otherwise (bash `if` compatible).
#
# USAGE EXAMPLE:
#
#     loadserver "${server}" ||
#       fatal "Could not read server configuraion for '${server}'."
#     identity=$(get $(ns ${server} _identity))
#     user=$(get $(ns ${server} _user))
#     host=$(get $(ns ${server} _host))
#     opts=$(get $(ns ${server} _sshopts))
#
function loadserver {
  file="$SCRIPTHOME/servers/$1.server"
  [ -f "$file" ] || return 1
  . "$file" || return 1
  n=$(ns $1 _alias); export $n="${!n}"
  n=$(ns $1 _host); export $n="${!n}"
  n=$(ns $1 _user); export $n="${!n}"
  n=$(ns $1 _identity); export $n="${!n}"
  n=$(ns $1 _options); export $n="${!n}"
  # TODO test required values and check alias against $1
  return 0
}

# -------------------------------------------------------
# ssh_pw_required(host, user, identity_file, ssh_options)
# -------------------------------------------------------
#
# Utility: Test if a particular user@host requires a password for SSH access.
#
# ARGS:  - user: ssh username
#
#        - host: ssh host
#
#        - identity_file: ssh .pem identity file (-i) (optional). If a valid
#          identity file is supplied this function returns false (nonzero).
#
#        - ssh_options: additional ssh options (optional).
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    None
#
# DEPS:    ssh
#
# RETURN:  0 if password is required, 1 otherwise (bash `if` compatible).
#
# USAGE EXAMPLE:
#
#   ssh_pw_required "fletch" "mysite.com" &&
#     echo "A password is required to login to mysite.com with user fletch."
#
function ssh_pw_required {
  args="-n -o PasswordAuthentication=no"
  [ -f "$3" ] && args+=" -i $3"
  [ -n "$4" ] && args+=" $4"
  args+=" -l $2 $1"
  ! ${SSH} $args 2> /dev/null # Invert to answer the question of the function.
}

# -----------------------
# sshcmd(host, user, ...)
# -----------------------
#
# Utility: Low level remote access function. Most code should use `remote`.
# TODO: pass PROGRAM and COLUMNS to remote via (hidden?) command line switches.
#
# ARGS:  - host: SSH host.
#
#        - user: SSH username.
#
#        - ...: server commands and arguments, commands separated by "--".
#
# STDIN:   Unused
#
# STDOUT:  Remote command(s) output.
#
# VARS:    $IDENTITY_FILE: SSH .pem identity file (-i)
#
#          $SSH_OPTIONS: additional SSH options
#
# DEPS:    ssh
#
# RETURN:  0 if the command(s) succeeded or a nonzero error status otherwise.
#
# USAGE EXAMPLE:
#
#   sshcmd mysite.com fletch ping # Prints `uname -a` from the server.
#
function sshcmd {
  local host=$1; shift
  local user=$1; shift
  local options=$(get SSH_OPTIONS)
  local identity=$(get IDENTITY_FILE)
  [ -f "$identity" ] && options+=" -i ${identity}"
  [ -n "$user" ] && options+=" -l ${user}"
  options+=" ${host}"
  local script="arguments=( $(printf " %q" "$@") )"$'\n'
  script+="$(cat "$SCRIPTPATH")"$'\n'
  # So far this rather clumsy method of passing the entire script as the
  # command string is the only way to achieve copying this file to the server
  # and running it in a single shot. Attempts to do it using stdin break
  # SSH's pty and then prompting functions and sudo fail to work on remote.
  # Still looking for a nicer way to achieve it.
  ${SSH} -Ctt ${options} "${script}" 2>&1 | grep -v "^Connection to .* closed\..*$"
}

# -------------------
# remote(server, ...)
# -------------------
#
# Utility: Remote access.
#
#              ---- TODO MORE COMPLETE, UPDATE THESE DOCS ----
#
# ARGS:  - server: Server alias.
#
#        - ...: server commands and arguments, commands separated by "--".
#
# STDIN:   Unused
#
# STDOUT:  Remote command(s) output.
#
# VARS:    None
#
# DEPS:    ssh
#
# RETURN:  0 if the command(s) succeeded or a nonzero error status otherwise.
#          255 if the specified server info could not be loaded.
#
# USAGE EXAMPLE:
#
#   remote mysite ping # Prints `uname -a` from the server.
#
function remote {
  local -r server="$1"; shift
  loadserver "${server}" || return 255
  local -r identity="$(get $(ns ${server} _identity))"
  local -r options="$(get $(ns ${server} _sshopts))"
  local -r user="$(get $(ns ${server} _user))"
  local -r host="$(get $(ns ${server} _host))"
  IDENTITY_FILE="${identity}" SSH_OPTIONS="${options}" \
    sshcmd "${host}" "${user}" --remote "$@"
}

# -----------------------
# prog(variable, program)
# -----------------------
#
# Utility: Check for the existence of 'program'. If the program exists, this
# function will export 'variable' to the path of the program and return 0 (bash
# `if` compatible). If 'program' doesn't exist it returns 1 and exports nothing.
#
# ARGS:  - variable: Name of a variable to export.
#
#        - program: Program to check for.
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    None
#
# DEPS:    None
#
# RETURN:  0 if the program exists, 1 otherwise (bash `if` compatible).
#
# USAGE EXAMPLES:
#
#   prog ENV env || fatal "NO ENV HOLY CRAP WHATDO!"
#   echo ENV: $ENV
#
function prog {
  cmd="$(command -v $2)"
  [ ! -f "$cmd" ] && cmd="$(which $2 2> /dev/null)" # $(command) doesn't work when alias.
  [ ! -f "$cmd" ] && return -1 # $(command) and $(which) failed, bail.
  [ -x "$cmd" ]
  rval=$?
  [ $rval ] && export $1="$(command -v $2)"
  return $rval
}

# ------------------------------
# func(function)
# ------------------------------
#
# Utility: Test if local function is defined.
#
# ARGS:  - function: Function name to check for.
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    None
#
# DEPS:    None
#
# RETURN:  0 if the function exists, 1 otherwise (bash `if` compatible).
#
# USAGE EXAMPLES:
#
#   if func $(ns $COMMAND _myhook); then
#     $(ns $COMMAND _myhook) arg arg arg
#   fi
#
function func {
#  [ "$(type -t $1)" = "function" ]
  local -f $1 > /dev/null
  return $?
}

# -------
# ns(...)
# -------
#
# Utility: Squeeze arguments together to make a namespaced function or variable
# name. Used to build dynamic names.
#
# ARGS:  - ... names to concatinate.
#
# STDIN:   Unused
#
# STDOUT:  Generated function name.
#
# VARS:    None
#
# DEPS:    sed
#
# RETURN:  Unused
#
# USAGE EXAMPLES:
#
#    $(ns "n" "s")                              -->  `ns`
#    $(ns "ns") arg arg arg                     -->  argargarg
#    $(ns "n" "s") arg arg arg                  -->  argargarg
#    $(ns "echo") arg arg arg                   -->  arg arg arg
#    $(ns "ec" "ho") arg arg arg                -->  arg arg arg
#    echo "++ $($(ns "n" "s") arg arg arg) ++"  -->  ++ argargarg ++
#    echo "++ `$(ns "n" "s") arg arg arg` ++"   -->  ++ argargarg ++
#
function ns {
  ${SED} "s/\s//g" <<< "$@"
}

# ------------------------
# valid_command(command)
# ------------------------
#
# Utility: Test if given command is NOT in the command list.
#
# ARGS:  - command: Command to test for.
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    $COMMANDS: Input, global list of commands.
#
# RETURN:  0 if the command is valid, 1 otherwise (bash `if` compatible).
#
# USAGE EXAMPLES:
#
#   if ! valid_command $COMMAND; then
#     usage "Unknown command \"$COMMAND\""; exit -2;
#   fi
#
function valid_command {
  [[ "$COMMANDS" =~ (^| )"$1"($| ) ]]
  return $?
}

# -------------------------
# valid_number(min, max, n)
# -------------------------
#
# Utility: Check if a number is valid and in a given range.
#
# ARGS:  - min: Minimum value.
#
#        - max: Maximum value.
#
#        - n: String to test.
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:    None
#
# RETURN:  0 if the number is valid, 1 otherwise (bash `if` compatible).
#
function valid_number {
  [ -n "$3" ] &&
  [[ "$3" =~ ^[0-9]+$ ]] &&
  [ $3 -ge $1 ] &&
  [ $3 -lt $2 ] &&
    return 0 ||
    return 1
}

# TODO documentation.
function trim {
  sed 's/^[[:space:]]*//g; s/[[:space:]]*$//g;' <<< "$1"
}

# TODO documentation.
function string_contains {
  grep "$2" <<< "$1" >> /dev/null
}

# -------------------------------------------------------
# read_arrays(variable1 [, variable2 [, variable3 ... ]])
# -------------------------------------------------------
#
#  ------------- TODO FIX UP THESE DOCS ----------------
#
#  * Removes lines that contain only a comment.
#  * Removes empty lines.
#  * Removes comments from the end of lines.
#  * Trims extra whitespace from the start and end of lines.
#
# ARGS:  - variable: Name of variable to set with array results.
#
# STDIN:   Stream of line(s) to read.
#
# STDOUT:  Unused
#
# VARS:  - ${!variable}: Output variable to hold array result.
#
#        - $PREPROCESS: Input - Name of a function to call to rewrite valid
#          lines. PREPROCESS(line). If specified, function should `echo` the
#          altered line.
#
#        - $PREFIX: Input - Text to insert before valid input lines. Alternate
#          way to do similar as PREPROCESS without writing a separate function.
#
#        - $SEPARATOR: Input - Column separator that delineates array items.
#          Default if not specified is "|".
#
# RETURN:  Similar to bash build-in read function: zero on success, non-zero
#          value on error or EOF.
#
# USAGE EXAMPLES:
#
#   TODO
#
function read_arrays {
  local -r sep=$(get SEPARATOR '|')
  local orig line
  local source=""
  mapfile -t orig < <(grep -vE '^[\s]*#|^[\s]*$' | sed "s/#[^$]*$//g; s/^[[:space:]]*//g; s/[[:space:]]*$//g; s/[[:space:]]*${sep}[[:space:]]*/${sep}/g")
  [ ${#orig[@]} = 0 ] && return
  for line in "${orig[@]}"; do
    [ -n "$PREPROCESS" ] && line=`$PREPROCESS "${line}"`
    [ -n "$PREFIX" ] && line="$PREFIX ${line}"
    [ -n "$PREPROCESS" -o -n "$PREFIX" ] &&
      line="$(sed "s/#[^$]*$//g; s/^[[:space:]]*//g; s/[[:space:]]*$//g; s/[[:space:]]*${sep}[[:space:]]*/${sep}/g" <<< "${line}")"
    [ -n "${source}" ] && source+=$'\n'
    source+="${line}"
  done
  [ -z "${source}" ] && return
  for i in $(seq 1 $#); do
    mapfile -t $1 < <(awk -F "${sep}" "{print \$${i}}" <<< "${source}")
    shift
  done
}

# -------------
# tableformat()
# -------------
#
# Utility: Format a table.
#
# ARGS:    None
#
# STDIN:   Stream of line(s) containing records. Cells are separated with a
#          "|" character. A row can consist of a single "-", "_", or "="
#          character which will be replaced with a separator line. Blank lines
#          are ignored. Extra whitespace around cell values is removed and
#          multiple spaces in the cell value are replaced with one.
#
# STDOUT:  Formatted table.
#
# VARS:    $WIDTH: Width of the table. Actual width of the table will be
#          smaller than this value by (MARGIN*2). The default value is
#          $COLUMNS if that variable is set, or 80 if not.
#
#          $MARGIN: Spaces to the left and right of the table. Default is 5.
#
#          $SEPARATOR: Character to separate records in input. Default is "|".
#
#          $ROWSPACING: Add space between rows. Default is 0.
#
#          $OPTIONS: 'Global options' from `tbl`. See `man tbl` for details.
#
#          $FORMAT: Table format specification from `tbl` for table body rows.
#          See `man tbl` for details.
#
#          $HEADER_FORMAT: Table format specification from `tbl` for the table
#          header row. See `man tbl` for details.
#
#          $OUTPUT_MODE: 'ascii' or 'utf8'. Default is utf8 which makes nicer
#          borders and bold/italics but may not work everywhere.
#
# DEPS:    sed tr tbl groff
#
# RETURN:  Unused
#
# USAGE EXAMPLES:
#
#   ---------
#   Example 1
#   ---------
#
#   echo -e "\n"
#   FORMAT="l lx" tableformat <<EOF
#     Arguments|
#
#     --someoption,-s | This is an option value with a really really long \
#                       description. It just keeps going. You know I think I \
#                       write more documentation and help strings than actual \
#                       code.
#
#     --another,-a    | Another option let's make a nice table.
#   EOF
#
#   # ... outputs ...
#
#     Arguments
#
#     --someoption,-s   This  is  an option value with a really really long
#                       description. It just keeps going. You know I  think
#                       I  write  more  documentation and help strings than
#                       actual code.
#
#     --another,-a      Another option let’s make a nice table.
#
#   ---------
#   Example 2
#   ---------
#
#   FORMAT="l|lx" HEADER_FORMAT="lb|lb" tableformat <<EOF
#     Abc|Def
#     _
#     --someoption,-s | This is an option value with a really really long \
#                       description. It just keeps going. You know I think I \
#                       write more documentation and help strings than actual \
#                       code.
#     --another,-a    | Another option let's make a nice table. \
#                       `printf " well hello there%.s" {1..30}`
#   EOF
#
#   # ... outputs ...
#
#     Abc             │ Def
#     ────────────────┼─────────────────────────────────────────────────────
#     --someoption,-s │ This  is  an option value with a really really long
#                     │ description. It just keeps going. You know I  think
#                     │ I  write  more  documentation and help strings than
#                     │ actual code.
#     --another,-a    │ Another option let’s make a nice table. well  hello
#                     │ there  well hello there well hello there well hello
#                     │ there well hello there well hello there well  hello
#                     │ there  well hello there well hello there well hello
#                     │ there well hello there well hello there well  hello
#                     │ there  well hello there well hello there well hello
#                     │ there well hello there well hello there well  hello
#                     │ there  well hello there well hello there well hello
#                     │ there well hello there well hello there well  hello
#                     │ there  well hello there well hello there well hello
#                     │ there well hello there well hello there
#
#   ---------
#   Example 3
#   ---------
#
#   OPTIONS="allbox" FORMAT="cw3 cw3 cw3" tableformat <<EOF
#     a | b | c
#     d | e | f
#     g | h | i
#   EOF
#
#   # ... outputs ...
#
#     ┌────┬─────┬─────┐
#     │ a  │  b  │  c  │
#     ├────┼─────┼─────┤
#     │ d  │  e  │  f  │
#     ├────┼─────┼─────┤
#     │ g  │  h  │  i  │
#     └────┴─────┴─────┘
#
function tableformat {

  # Variables init.
  ncolumns=0
  unset body
  tab="`echo -e "\t"`"
  margin=$(get MARGIN 5)
  width=$(get WIDTH $(get COLUMNS 80))
  width=$(($width-$margin-$margin-1))
  rowspacing="$(repeat $(get ROWSPACING 0) $'\n')"
  sep=$(get SEPARATOR '|')
  mode=$(get OUTPUT_MODE utf8)

  # Read records from stdin. Count columns.
  while IFS="$sep" read -a a; do
    [ ${#a[@]} = 0 ] && continue
    i=0
    for field in "${a[@]}"; do
      # TODO figure out how to get rid of `echo -e` here.
      i=$((i+1))
      v="$(echo -e "${field}" | ${SED} -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | ${TR} -s ' ')"
      [ -z "${v}" ] && continue
      [ $i -gt 1 ] && body+="${tab}"
      [ ${#v} = 1 ] &&
        body+="${v}${rowspacing}" ||
        body+=$'T{\n'"${v}${rowspacing}"$'\nT}'
    done
    body+=$'\n'
    ncolumns=$(($i>$ncolumns?$i:$ncolumns))
  done

  # Format strings.
  header=".ll ${width}m"$'\n'
  header+=".po ${margin}m"$'\n'
  header+=$'.pl 999999\n'
  header+=$'.char \[hy] -\n'
  header+=$'.char \[oq] `\n'
  header+=$'.char \[cq] \'\n'
  header+=$'.TS\n'
  [ -n "$OPTIONS" ] && header+="$OPTIONS"$';\n'
  [ -n "$HEADER_FORMAT" ] && header+="$HEADER_FORMAT"$'\n'
  [ -n "$FORMAT" ] && \
    header+="$FORMAT"$'.\n' || \
    header+="$(repeat $ncolumns 'lex ')"$'.\n'
  footer=$'.TE'
  footer+=$'\n.pl \\n[nl]u'
  fmtstr="${header}${body}${footer}"

  # Use `tbl | groff` for formatting. `grotty` seems to have a spurious error
  # sometimes so /dev/null STDERR on groff (which calls grotty).
  #echo "${fmtstr}"
  ${TBL} <<< "${fmtstr}" | ${GROFF} "-T${mode}" 2>/dev/null
}

# -----------
# paragraph()
# -----------
#
# Utility: Format paragraphs.
#
# ARGS:    None
#
# STDIN:   [ TODO DOCUMENT ME ]
#
# STDOUT:  Formatted paragraph.
#
# VARS:    [ TODO DOCUMENT ME ]
#
# DEPS:    sed tr tbl groff
#
# RETURN:  Unused
#
# USAGE EXAMPLE:
#
#   [ TODO DOCUMENT ME ]
#
function paragraph {
  SEPARATOR="" MARGIN="$(get MARGIN 3)" ROWSPACING=1 tableformat
}

# -------
# usage()
# -------
#
# Utility: Display program usage.
#
# ARGS:    None
#
# STDIN:   Unused
#
# STDOUT:  Usage message.
#
# VARS:    $PROGRAM: The program name as specified in $0 of the script.
#
#          $COMMANDS: Input, global list of commands.
#
# DEPS:    sed tr tbl groff
#
# RETURN:  Unused
#
# USAGE EXAMPLES:
#
#    usage; exit 0
#
function usage {
  unset helpdata
  for cmd in $COMMANDS; do
    helpdata+="$cmd|$($(ns $cmd _shorthelp))"$'\n'
  done
  echo -e "Usage: $PROGRAM [GLOBAL ARGUMENTS] COMMAND (COMMAND ARGUMENTS) [-- COMMAND (COMMAND ARGUMENTS)]...\n"
  FORMAT="llx" MARGIN="3" tableformat <<EOF
    GLOBAL ARGUMENTS
    _
    -y,--yes       | Automatically answer \"y\" to yes/no questions and \
                     accept the default value for other types of questions. \
                     Does not work for all commands.
    -a,--ascii     | If your terminal is displaying odd characters when \
                     running \`$PROGRAM\` it may not support utf8, try this.
    COMMANDS
    _
    $helpdata
    help [COMMAND] | Display help for a specific command.
EOF
  [ -n "$1" ] && echo "ERROR: $1."
}

# --------------------
# fatal(...)
# --------------------
#
# Utility: print an fatal and exit
#
# ARGS:  - ...: Messages to display regarding what went wrong.
#
# STDIN:   Unused
#
# STDOUT:  Usage message.
#
# VARS:    $EXITCODE: Code to exit with. Default is 1.
#
# DEPS:    sed tr tbl groff
#
# RETURN:  Unused
#
# USAGE EXAMPLES:
#
#    fatal "Something went wrong! (details ...)"
#
function fatal {
  exitcode=$(get EXITCODE 1)
  echo -e "$*" | MARGIN="0" paragraph > /dev/stderr
  exit $exitcode
}

# ------------------------
# longhelp(command, usage)
# ------------------------
#
# Utility: Format command specific help.
#
# ARGS:  - command: Command we're giving long help for.
#
#        - usage: Usage string.
#
# STDIN:   Detailed help text.
#
# STDOUT:  Formatted help message.
#
# VARS:    None
#
# DEPS:    sed tr tbl groff
#
# RETURN:  Unused
#
# USAGE EXAMPLES:
#
#   longhelp $1 "$PROGRAM delserver [SERVERNAME]" <<EOL
#     Delete a server by alias.
#   EOL
#
function longhelp {

  command="$1"
  shift

  while [ -n "$1" ]; do
    echo "$1" | sed 's/^/   /'
    shift
  done

  echo
  FORMAT="lw8lx" HEADER_FORMAT="lb" tableformat <<EOF
    Synopsis
    _
    Command: | $command
    Summary: | $($(ns $command _shorthelp))
EOF

  echo
  # TODO cat below isn't working right, or tableformat isn't normalizing space
  # right. Also TODO, add a table debugging program switch.
  FORMAT="lx" HEADER_FORMAT="lb" tableformat <<EOF
    Details
    _
    `cat`
EOF

}

# TODO docs!
# argshelp(command, usage)
function argshelp {
  local -r configvar="$1"
  local -r config=
  shift
  local helplines=""

  local -a argshelp_fields
  local -a argshelp_defaults
  local -a argshelp_labels
  local -a argshelp_prompts
  local -a argshelp_longopts
  local -a argshelp_shortopts
  local -a argshelp_descriptions
  local -a argshelp_visibility
  local -a argshelp_promptfns
  local -a argshelp_displayfns
  local -a argshelp_required

  read_arrays \
    argshelp_fields \
    argshelp_defaults \
    argshelp_labels \
    argshelp_prompts \
    argshelp_longopts \
    argshelp_shortopts \
    argshelp_descriptions \
    argshelp_visibility \
    argshelp_promptfns \
    argshelp_displayfns \
    <<< "${!configvar}"

  for i in "${!argshelp_fields[@]}"; do
    [ -z "${argshelp_longopts[$i]}" ] &&
    [ -z "${argshelp_shortopts[$i]}" ] &&
      continue
    [ -n "${argshelp_longopts[$i]}" ] &&
      helplines+="${argshelp_longopts[$i]}"
    [ -n "${argshelp_longopts[$i]}" ] &&
    [ -n "${argshelp_shortopts[$i]}" ] &&
      helplines+=","
    [ -n "${argshelp_shortopts[$i]}" ] &&
      helplines+="${argshelp_shortopts[$i]}"
    helplines+="|${argshelp_descriptions[$i]}"$'\n'
  done

  while [ -n "$1" ]; do
    MARGIN="3" paragraph <<< "$1"
    shift
  done

  FORMAT="lw18 lx" HEADER_FORMAT="lb" tableformat <<EOF
    Arguments
    _
    $helplines
EOF
  longhelp "$command"
}

# Utility: Check `sudo` access. Sets PREFLGHT_ERROR and returns a nonzero value
# if the access check failed.
function preflight_sudo {
  # TODO!
  PREFLGHT_ERROR=""
  return 1
}

#------------------------------------------------------------------------------
# UI: promptfn implementations
#------------------------------------------------------------------------------

# -------------------------------
# prompt(resultvar, message, ...)
# -------------------------------
#
# Utility: Similar to the bash built-in `read` function.
#
# Note this function DOES NOT implement the promptfn interface of multiprompt.
# It is a lower level utility and promptfn implementations can be build using
# this as a utility.
#
# ARGS:  - resultvar: Variable to store user input result.
#
#        - message: Prompt message.
#
#        - ...: Remaining arguments contain valid values. If additional
#          args are given, the user input is required to conform. If no
#          additional arguments are given, the input is unconstrained and
#          may be empty.
#
# STDIN:   Read user input.
#
# STDOUT:  Prompt message.
#
# VARS:    ${!resultvar} [OUT]: Output variable set to user input.
#
#          $DEFAULT [IN]: Value to pass as default to read.
#
#          $SILENT [IN]: Set to any nonempty value to use silent mode.
#
# RETURN:  Unused
#
# USAGE EXAMPLES:
#
#   prompt name "What's your name?"
#   echo "Well hello, ${name}."
#
#   prompt ynresult "Do you like fruit? (y/n)" "y" "n"
#   [ $ynresult = y ] && echo "Great, fruit is good for you." \
#      || echo "You really should get out more often."
#
function prompt {
  # TODO better result regex handling? do we need it? and docs for it.
  resultvar=$1
  message=$2
  shift; shift
  result=""
  [ -n "${SILENT}" ] && silent="-s" || silent=""
  [ -n "${DEFAULT}" ] && default="-i${DEFAULT}" || default=""
  if [ -n "$*" ]; then
    while [[ ! "$@" =~ (^| )"$result"($| ) ]]; do
      read ${silent} ${default} -ep "$message: " result < ${TTY} >> ${TTY}
    done
  else
    read ${silent} ${default} -ep "$message: " result < ${TTY} >> ${TTY}
  fi
  [ -n "${SILENT}" ] && echo
  export $resultvar="$result"
}

# ------------------------------------------
# ynprompt(fieldname, prompt_message, label)
# ------------------------------------------
#
# Implements multiprompt/promptfn().
#
# Yes / no choice prompt.
#
# SEE ALSO: multiprompt for promptfn details.
#
function ynprompt {
  echo
  [ -n "$3" ] &&
    DEFAULT="$3" prompt ynresult "$2 (y/n)" "y" "n" ||
    prompt ynresult "$2 (y/n)" "y" "n"
  export $1=$ynresult
  [ "${ynresult}" = "y" ]
}

# --------------------------------------------
# textprompt(fieldname, prompt_message, label)
# --------------------------------------------
#
# Implements multiprompt/promptfn().
#
# Basic text field prompt.
#
# SEE ALSO: multiprompt for promptfn details.
#
function textprompt {
  echo
  f="$1"
  v="${!f}"
  IFS="^?" DEFAULT="${v}" prompt v "$2"
  [ -n "${v}" ] && export $1="${v}"
}

# ------------------------------------------
# pwprompt(fieldname, prompt_message, label)
# ------------------------------------------
#
# Implements multiprompt/promptfn().
#
# Presents a password prompt that does not echo characters to the screen.
#
# SEE ALSO: multiprompt for promptfn details.
#
function pwprompt {
  echo
  while : ; do
    SILENT="1" prompt prompt1 "$2"
    SILENT="1" prompt prompt2 "$2 (again)"
    [ "$prompt1" = "$prompt2" ] &&
      break ||
      echo "Passwords do not match, please try again."
  done
  export $1="${prompt1}"
}

# ----------------------------------------------
# serverprompt(fieldname, prompt_message, label)
# ----------------------------------------------
#
# Implements multiprompt/promptfn().
#
# Presents a radioprompt based selection of available servers.
#
# SEE ALSO: multiprompt for promptfn details.
#
function serverprompt {
  local f
  local config=""
  local -r serverprompt_field="$1"
  local -a servers
  for f in "$(ls "$SCRIPTHOME/servers/"*.server)"; do
    local n="$(basename "${f}")"
    local server="$(sed 's/\.server//g' <<< "${n}")"
    loadserver "${server}"
    local host="$(get $(ns "${server}" _host))"
    config+="${server}|${server}: ${host}"$'\n'
    servers[${#servers[@]}]="${server}"
  done
  # TODO if 0 servers, fatal; if 1 server, auto pick; else prompt.
  if [ ${#servers[@]} = 0 ]; then
    fatal "No servers are configured, please run $PROGRAM addserver."
  elif [ ${#servers[@]} = 1 ]; then
    echo
    echo "Only one server is configured, selecting \"${servers[0]}\"."
    export ${serverprompt_field}="${servers[0]}"
  else
    PROMPT="" radioprompt "${!serverprompt_field}" "$2" 3 <<< "${config}"
    export ${serverprompt_field}="${selected_value}"
  fi
}

# --------------------------------------------
# fileprompt(fieldname, prompt_message, label)
# --------------------------------------------
#
# Implements multiprompt/promptfn().
#
# Presents a file selection prompt. Supports autocomplete. Function loops and
# will not exit unless a valid existing file is selected.
#
# SEE ALSO: multiprompt for promptfn details.
#
function fileprompt {
  fileprompt_field="$1"
  while : ; do
    textprompt "$@"
    export ${fileprompt_field}="$(trim "${!fileprompt_field}")"
    [ -f "${!fileprompt_field}" ] && break
    echo "Sorry I could not find or read file: ${!fileprompt_field}"
    echo "Please try again."
  done
}

# --------------------------------------------
# cboxprompt(fieldname, prompt_message, label)
# --------------------------------------------
#
# Implements multiprompt/promptfn().
#
# Toggles a checkbox.
#
# SEE ALSO: multiprompt for promptfn details.
#
function cboxprompt {
  # Don't bother with input, just toggle the state.
  [ "${!1}" = "y" ] && export $1=n || export $1=y
}

# -------------------------------------------
# radprompt(fieldname, prompt_message, label)
# -------------------------------------------
#
# Implements multiprompt/promptfn().
#
# Toggles a radio button. Used by radioprompt().
#
# SEE ALSO: multiprompt for promptfn details.
#
function radprompt {
  # Don't bother with input, just toggle the state.
  export selected_index="${i}" # $i = selected index
  export selected_value="$1" # $1 = field name
  export selected_label="${labels[$selected_index]}"
}

# ------------------------------------------------------------
# recordsprompt_group_prompt(fieldname, prompt_message, label)
# ------------------------------------------------------------
#
# Implements multiprompt/promptfn().
#
# A promptfn() implementation used by recordsprompt().
#
# SEE ALSO: multiprompt for promptfn details.
#
function recordsprompt_group_prompt {
  GROUP="$3" PROMPT="${recordprompt}" recordsprompt \
    "${recordsfield}" "${recordslabel}" "${recorddisplayfn}" "${addfn}" "${delfn}"
}

# ------------------------------------------------------------
# recordsprompt_addfn_prompt(fieldname, prompt_message, label)
# ------------------------------------------------------------
#
# Implements multiprompt/promptfn().
#
# A promptfn() implementation used by recordsprompt().
#
# SEE ALSO: multiprompt for promptfn details.
#
function recordsprompt_addfn_prompt {
  local -r records="$1"
  recordsnextkey ${records}
  local -r nextkey=$?
  ${addfn} "${records}" "${nextkey}" "$3"
  return 1
}

# ------------------------------------------------------------
# recordsprompt_delfn_prompt(fieldname, prompt_message, label)
# ------------------------------------------------------------
#
# Implements multiprompt/promptfn().
#
# A promptfn() implementation used by recordsprompt().
#
# SEE ALSO: multiprompt for promptfn details.
#
function recordsprompt_delfn_prompt {
  ${delfn} "$1" "$2" "$3"
  return 2
}

# ----------------------------------------------------------
# multiprompt_group_prompt(fieldname, prompt_message, label)
# ----------------------------------------------------------
#
# Implements multiprompt/promptfn().
#
# A promptfn() implementation used by multiprompt().
#
# SEE ALSO: multiprompt for promptfn details.
#
function multiprompt_group_prompt {
  GROUP="$1" PROMPT="$2" multiprompt "$3" "${num_columns}" <<< ""
}

#------------------------------------------------------------------------------
# UI: displayfn implementations
#------------------------------------------------------------------------------

# -----------------------------------------
# display(fieldname, label, prompt_message)
# -----------------------------------------
#
# Implements multiprompt/displayfn().
#
# Standard default displayfn() implementation, print the label plus the value
# if there is one set.
#
# SEE ALSO: multiprompt for displayfn details.
#
function display {
  [ -n "${!1}" ] && echo "$2: ${!1}" || echo "$2"
}

# -------------------------------------------------------------
# recordsprompt_addfn_display(fieldname, label, prompt_message)
# -------------------------------------------------------------
#
# Implements multiprompt/displayfn().
#
# A displayfn() implementation used by recordsprompt().
#
# SEE ALSO: multiprompt for displayfn details.
#
function recordsprompt_addfn_display {
  get ADDLABEL "Add new ${recordslabel}"
}

# -------------------------------------------------------------
# recordsprompt_delfn_display(fieldname, label, prompt_message)
# -------------------------------------------------------------
#
# Implements multiprompt/displayfn().
#
# A displayfn() implementation used by recordsprompt().
#
# SEE ALSO: multiprompt for displayfn details.
#
function recordsprompt_delfn_display {
  get DELLABEL "Remove ${recordslabel}"
}

# --------------------------------------------
# raddisplay(fieldname, label, prompt_message)
# --------------------------------------------
#
# Implements multiprompt/displayfn().
#
# displayfn() implementation used by radioprompt().
#
# SEE ALSO: multiprompt for displayfn details.
#
function raddisplay {
  [ "${selected_index}" = "${n}" ] && echo "(*) $2" || echo "( ) $2"
}

# ---------------------------------------------
# cboxdisplay(fieldname, label, prompt_message)
# ---------------------------------------------
#
# Implements multiprompt/displayfn().
#
# displayfn() implementation used by checkboxprompt().
#
# SEE ALSO: multiprompt for displayfn details.
#
function cboxdisplay {
  [ "${!1}" = "y" ] && echo "[X] $2" || echo "[ ] $2"
}

#------------------------------------------------------------------------------
# UI: high level prompts
#------------------------------------------------------------------------------

# -------------------------------
# multiprompt(title, num_columns)
# -------------------------------
#
# Display a menu of choices to user, enabling them to change value by number.
# Individual list item display and prompting are controlled by the
# configuration data descibed below in STDIN.
#
# ARGS:  - title: Text to show above the option listing.
#
#        - num_columns: Number of columns in the listing. Optional. Default=3.
#
# STDIN:   Rows of field records. Columns are separated with "|" by default
#          and rows are separated with a newline character. Lines starting with
#          a '#' character are ignored. Empty lines are ignored. Comments at
#          the end of line starting with '#' and continuing to end of line are
#          removed. Data table format:
#
#              [column 1] promptfn
#              -------------------
#              SIG:  promptfn(fieldname, prompt_message, label)
#              VARS: i (selected index).
#              Prompt function called to change an item value. This function
#              should ask for user input if needed and export the field value.
#              Alternately prompt functions may take some automatic action such
#              as toggling a checkbox and return immediately without direct
#              user input. Note that it is safe to recursively call other
#              prompt functions that are based on multiprompt.
#
#              [column 2] displayfn
#              --------------------
#              SIG:  displayfn(fieldname, label, prompt_message)
#              VARS: i (selected index).
#              Display function should print the item to stdout. The result is
#              used for display in menu listings. Keep the text short so the
#              display will work nicely with the given num_columns.
#
#              [column 3] default
#              ------------------
#              Default value for the field. It will only be applied if the
#              variable of the field doesn't already contain a value.
#
#              A default value of "=PROMPT" means prompt the user immediately
#              for a value before entering menu mode.
#
#              A default value of "=GROUP" sets the prompt function to a
#              recursive sub-group multiprompt. If a user prompt function for
#              a =GROUP item, it should work similarly to
#              multiprompt_group_prompt or call that function directly.
#
#              [column 4] fieldname
#              --------------------
#              Name of the field. Must be a single word name, it is used as
#              bash variable name.
#
#              [column 5] label
#              ----------------
#              Short label for the field. Passed to the display and prompt
#              functions.
#
#              [column 6] promptmessage
#              ------------------------
#              Message to display when prompting for a value. Passed to the
#              display and prompt functions.
#
#              [column 7] visibility
#              ---------------------
#              Optional menu visibility control. The format of this column is:
#
#                group[predicate][predicate]...
#
#              "group" may be empty. An empty group traditionally represents
#              the top level menu. If group is supplied then this item will
#              only be displayed when browsing the sub-menu with that group
#              name.
#
#              Each optional "predicate" is of the form [name=value]. A
#              predicate resolves true if bash variable with "name" is equal
#              to the given value. The item will only be displayed if all
#              predicates resolve true.
#
#              Example: addserver_httpd[addserver_httpdtype=apache2]
#
#              In this example the item will be displayed when (1) the user
#              is viewing sub-menu group "addserver_httpd" and (2) the bash
#              variable ${addserver_httptype} is equal to "apache2".
#
# STDOUT:  Interactive.
#
# VARS:  - Each field is exported as a variable with the user configured value.
#
#        - $fields: Output array of field names that were processed.
#
#        - $labels: Output array of labels corresponding to the fields list.
#
#        - $INIT: Input - specify a function to run after parsing STDIN data
#          but before displaying list for the first time. Init functions have
#          access to the following vars: fields (array), labels (array),
#          promptfns (array), displayfns (array), promptmessages (array).
#
#        - $PREPROCESS: Input - Name of a function to call to rewrite
#          configuration lines. PREPROCESS(line). If specified, function
#          should print the altered line to stdout.
#
#        - $PREFIX: Input - Text to insert before each configuration input
#          line. Alternate way to do similar as PREPROCESS without writing a
#          separate function.
#
#        - $PROMPT: Input - Message displayed during item selection. Default
#          is "Choose item or press [ENTER] to confirm"
#
#        - $SEPARATOR: Input - Column separator that delineates array items.
#          Default if not specified is "|".
#
#        - The following array variables may be set, and an empty string piped
#          to the function, which enables a wrapping implementation to do the
#          configuration parsing more efficiently than rewriting to a string.
#          See argsprompt for an example of this usage.
#
#              * ${multiprompt_promptfns[@]}
#              * ${multiprompt_displayfns[@]}
#              * ${multiprompt_defaults[@]}
#              * ${multiprompt_fields[@]}
#              * ${multiprompt_labels[@]}
#              * ${multiprompt_promptmsgs[@]}
#              * ${multiprompt_visibility[@]}
#
# RETURN:  Unused
#
# USAGE EXAMPLE:
#
#   See addserver_CONFIG for a complete example utilizing most features.
#
function multiprompt {

  local pmsg="$(get PROMPT 'Choose item or [ENTER] to confirm')"
  local multiprompt_promptfns=( "${multiprompt_promptfns[@]}" )
  local multiprompt_displayfns=( "${multiprompt_displayfns[@]}" )
  local multiprompt_defaults=( "${multiprompt_defaults[@]}" )
  local multiprompt_fields=( "${multiprompt_fields[@]}" )
  local multiprompt_labels=( "${multiprompt_labels[@]}" )
  local multiprompt_promptmsgs=( "${multiprompt_promptmsgs[@]}" )
  local multiprompt_visibility=( "${multiprompt_visibility[@]}" )
  local -a multiprompt_groups
  local -a multiprompt_predicates
  valid_number 1 64 $2 && local -r num_columns=$2 || local -r num_columns=3

  read_arrays \
    multiprompt_promptfns \
    multiprompt_displayfns \
    multiprompt_defaults \
    multiprompt_fields \
    multiprompt_labels \
    multiprompt_promptmsgs \
    multiprompt_visibility

  for i in "${!multiprompt_fields[@]}"; do
    local field="${multiprompt_fields[$i]}"
    multiprompt_groups[$i]="$(sed "s/[[:space:]]*\\([^\\[[:space:]]*\\)[^$]*$/\\1/g" <<< "${multiprompt_visibility[$i]}")"
    multiprompt_predicates[$i]="$(sed 's/\][[:space:]]*\[/|/g; s/[[:space:]]*\[/\[/g' <<< "${multiprompt_visibility[$i]}")"
    if [ -z "${!field}" ]; then # Value not already set.
      if [ "${multiprompt_defaults[$i]}" = "=PROMPT" ]; then
        # Magic value "=PROMPT" so promp user now.
        ${multiprompt_promptfns[$i]} \
          "${field}" \
          "${multiprompt_promptmsgs[$i]}" \
          "${multiprompt_labels[$i]}"
      else
        # Otherwise just set the default value.
        export ${field}="${multiprompt_defaults[$i]}"
      fi
    fi
    if [ "${multiprompt_defaults[$i]}" = "=GROUP" ]; then
      # Magic value "=GROUP", this item represents recursion into group.
      multiprompt_defaults[$i]=""
      [ -z "${multiprompt_promptfns[$i]}" ] &&
        multiprompt_promptfns[$i]="multiprompt_group_prompt"
    fi
  done

  # User init.
  [ -n "${INIT}" ] && ${INIT}

  while : ; do
    local n=1
    local table=""
    local -a selectmap
    for i in "${!multiprompt_fields[@]}"; do
      local field="${multiprompt_fields[$i]}"
      [ "${multiprompt_groups[$i]}" != "${GROUP}" ] && continue
      local j=2
      while : ; do
        local predicate="$(awk -F"[\\\\]|\\\\[|\\\\|]+" "{print \$${j}}" <<< "${multiprompt_predicates[$i]}")"
        [ -z "${predicate}" ] && break
        local testfield="$(sed 's/[[:space:]]*\([^\=[:space:]]*\)\=[^$]*/\1/g' <<< ${predicate})"
        local testvalue="$(sed 's/[^\=]*\=\([^$]*\)/\1/g' <<< ${predicate})"
        [ "${!testfield}" != "${testvalue}" ] && continue 2
        j=$((j+1))
      done
      local displayfn="${multiprompt_displayfns[$i]}"
      local label="${multiprompt_labels[$i]}"
      local promptmsg="${multiprompt_promptmsgs[$i]}"
      local display="$(${displayfn} ${field} "${label}" "${promptmsg}")"
      table+="|`printf \"%3s %s\" \"${n}.\" \"${display}\"`"
      [ $(($n % ${num_columns})) = 0 ] && table+=$'\n'
      selectmap[$n]="$i"
      n=$((n+1))
    done
    printf $'\n%s:\n\n' "$1"
    column -t -s "|" <<< "$table"
    echo
    prompt i "${pmsg}"
    [ -z "$i" ] && break # [ENTER] exits the loop
    selected="${selectmap[$i]}"
    if [ -z "${selected}" ]; then
      echo
      echo "Sorry I don't understand \"$i\". Please select one of the" \
           "displayed items or press [ENTER] to confirm."
      continue
    fi
    local field="${multiprompt_fields[$selected]}"
    local label="${multiprompt_labels[$selected]}"
    local promptfn="${multiprompt_promptfns[$selected]}"
    local promptmsg="${multiprompt_promptmsgs[$selected]}"
    local savedgroup="${GROUP}" # Stash the group, promptfn might change it.
    ${promptfn} "${field}" "${promptmsg}" "${label}"
    local promptresult=$?
    GROUP="${savedgroup}"
    [ ${promptresult} = 0 ] || return ${promptresult}
  done
  fields=${multiprompt_fields[@]}
  labels=${multiprompt_labels[@]}
}
# Hack, can't export globals so have to declare here and unset before using.
declare -a fields
declare -a labels

# ----------------------------------------
# recordsprompt(records, title, displayfn)
# ----------------------------------------
#
#                        ----- TODO COMPLETE DOCUMENTATION -----
#
# VARS:  - $RECORDPROMPT
#
#        - $PROMPT
#
#        - $TITLE
#
#        - $ADDFN addfn(records, keys, promptlabel)
#
#        - $DELFN delfn(records, key, promptlabel)
#
# USAGE EXAMPLE:
#
#  # Shows a list of all selected fruits in a fruit record.
#  function fruit_display {
#    local -r records="$1"
#    local -r key="$2"
#    local -r fields=( $3 )
#    local -a fruits
#    for i in ${!fields[@]}; do
#      local field="${records}_${key}_${fields[$i]}"
#      [ "${!field}" = "y" ] && fruits[${#fruits[@]}]="${recordsprompt_labels[$i]}"
#    done
#    [ ${#fruits[@]} -gt 0 ] && printf "%s " "${fruits[@]}" || printf "[NO FRUITS]"
#  }
#
#  fruit_0_cherries=y
#  fruit_0_oranges=y
#  fruit_1_lemons=n
#  fruit_1_limes=y
#  recordsprompt fruit "fruit" fruit_display <<EOF
#    cboxprompt | cboxdisplay | n | cherries | Cherries
#    cboxprompt | cboxdisplay | n | oranges  | Oranges
#    cboxprompt | cboxdisplay | n | pears    | Pears
#    cboxprompt | cboxdisplay | y | lemons   | Lemons
#    cboxprompt | cboxdisplay | n | limes    | Limes
#  EOF
#
function recordsprompt {

  # Local vars.
  local -r recordsfield="$1"
  local -r recordslabel="$2"
  local -r recorddisplayfn="$3"
  local -r addfn=$(get ADDFN recordsprompt_addfn)
  local -r delfn=$(get DELFN recordsprompt_delfn)
  local -r recordprompt="$(get RECORDPROMPT 'Choose item to edit or press [ENTER] to confirm')"
  local -r prompt="$(get PROMPT 'Choose a record to edit or press [ENTER] to confirm')"
  local -r title="$(get TITLE "Choose ${recordslabel} to edit or press [ENTER] to confirm")"

  if [ -z "$recordsprompt_fields" ]; then

    local -a recordsprompt_promptfns
    local -a recordsprompt_displayfns
    local -a recordsprompt_defaults
    local -a recordsprompt_fields
    local -a recordsprompt_labels
    local -a recordsprompt_promptmsgs

    # Parse the config.
    read_arrays \
      recordsprompt_promptfns \
      recordsprompt_displayfns \
      recordsprompt_defaults \
      recordsprompt_fields \
      recordsprompt_labels \
      recordsprompt_promptmsgs
  fi

  # Loop. If multiprompt returns with 1 we regenerate the menu.
  while : ; do

    local keys="$(recordskeys ${recordsfield})"
    local multiprompt_fields=( )
    local multiprompt_defaults=( )
    local multiprompt_labels=( )
    local multiprompt_promptmsgs=( )
    local multiprompt_visibility=( )
    local multiprompt_promptfns=( )
    local multiprompt_displayfns=( )

    # multiprompt config: add records listings
    for k in ${keys}; do
      multiprompt_promptfns[${#multiprompt_promptfns[@]}]="recordsprompt_group_prompt"
      multiprompt_displayfns[${#multiprompt_displayfns[@]}]="${recorddisplayfn}"
      multiprompt_defaults[${#multiprompt_defaults[@]}]=""
      multiprompt_fields[${#multiprompt_fields[@]}]="${recordsfield}"
      multiprompt_labels[${#multiprompt_labels[@]}]="${k}"
      multiprompt_promptmsgs[${#multiprompt_promptmsgs[@]}]="${recordsprompt_fields[@]}"
      multiprompt_visibility[${#multiprompt_visibility[@]}]=""
    done

    # multiprompt config: edit individual records
    for i in ${!recordsprompt_promptfns[@]}; do
      for k in ${keys}; do
        multiprompt_promptfns[${#multiprompt_promptfns[@]}]="${recordsprompt_promptfns[$i]}"
        multiprompt_displayfns[${#multiprompt_displayfns[@]}]="${recordsprompt_displayfns[$i]}"
        multiprompt_defaults[${#multiprompt_defaults[@]}]="${recordsprompt_defaults[$i]}"
        multiprompt_fields[${#multiprompt_fields[@]}]="$(ns ${recordsfield} _ ${k} _ ${recordsprompt_fields[$i]})"
        multiprompt_labels[${#multiprompt_labels[@]}]="${recordsprompt_labels[$i]}"
        multiprompt_promptmsgs[${#multiprompt_promptmsgs[@]}]="${recordsprompt_promptmsgs[$i]}"
        multiprompt_visibility[${#multiprompt_visibility[@]}]="${k}"
      done
    done

    # multiprompt config: "add new record" controls
    if [ -n "${addfn}" ]; then
      multiprompt_promptfns[${#multiprompt_promptfns[@]}]="recordsprompt_addfn_prompt"
      multiprompt_displayfns[${#multiprompt_displayfns[@]}]="recordsprompt_addfn_display"
      multiprompt_defaults[${#multiprompt_defaults[@]}]=""
      multiprompt_fields[${#multiprompt_fields[@]}]="${recordsfield}"
      multiprompt_labels[${#multiprompt_labels[@]}]="${multiprompt_fields[@]}"
      multiprompt_promptmsgs[${#multiprompt_promptmsgs[@]}]="${keys}"
      multiprompt_visibility[${#multiprompt_visibility[@]}]=""
    fi

    # multiprompt config: "delete record" controls
    if [ -n "${delfn}" ]; then
      for k in ${keys}; do
        multiprompt_promptfns[${#multiprompt_promptfns[@]}]="recordsprompt_delfn_prompt"
        multiprompt_displayfns[${#multiprompt_displayfns[@]}]="recordsprompt_delfn_display"
        multiprompt_defaults[${#multiprompt_defaults[@]}]=""
        multiprompt_fields[${#multiprompt_fields[@]}]="${recordsfield}"
        multiprompt_labels[${#multiprompt_labels[@]}]="${multiprompt_fields[@]}"
        multiprompt_promptmsgs[${#multiprompt_promptmsgs[@]}]="${k}"
        multiprompt_visibility[${#multiprompt_visibility[@]}]="${k}"
      done
    fi

    # Prompt.
    PROMPT="${prompt}" multiprompt "${title}" "1" <<< ""
    [ $? = 1 ] || break

  done
}

# ------------------------------------------
# recordsprompt_addfn(records, keys, fields)
# ------------------------------------------
# TODO: Document this.
#
function recordsprompt_addfn {
  local -r records="$1"
  local -r nextkey="$2"
  local -r fields=( $3 )
  for i in ${!fields[@]}; do
    field="${records}_${nextkey}_${fields[$i]}"
    value="${recordsprompt_defaults[$i]}"
    export ${field}="${value}"
  done
}

# -----------------------------------------
# recordsprompt_delfn(records, key, fields)
# -----------------------------------------
# TODO: Document this.
# TODO: Delete currently seems broken.
#
function recordsprompt_delfn {
  local -r records="$1"
  local -r key="$2"
  local -r fields=( $3 )
  local -r display="$(${recorddisplayfn} "${records}" "${key}" "$3")"
  ynprompt v "Really delete ${recordslabel} \"${display}\"?"
  if [ "${v}" = "y" ]; then
    for i in ${!fields[@]}; do
      field="${records}_${key}_${fields[$i]}"
      unset ${field}
    done
  fi
}

# --------------------
# recordskeys(records)
# --------------------
# TODO: Document this.
#
function recordskeys {
  # TODO: Find a better way to filter out functions (and other non-record vars).
  set | grep "^$1_" | grep -v '()' | sed "s/^$1_\([^_]*\)_.*/\1/g" | uniq | sort | sed ':a;N;$!ba;s/\n/ /g'
}

# -----------------------
# recordsnextkey(records)
# -----------------------
# TODO: Document this.
#
function recordsnextkey {
  local n=0
  for k in $(recordskeys $1); do
    valid_number 0 99999999 "$k" && n=$(($k>=$n?$k+1:$n))
  done
  return $n
}

# ------------------------------
# argsprompt(title, num_columns)
# ------------------------------
#
# Display a menu of choices to user, enabling them to change value by number.
# How list items are displayed and how the data is collected from the user are
# controlled by the field data descibed below in STDIN.
#
#                        ----- TODO FIX THESE DOCS -----
#
# ARGS:  - title: Text to show above the option listing.
#
#        - num_columns: Number of columns in the listing. Optional. Default=3.
#
# STDIN:   Rows of field records. Columns are separated with "|" by default
#          and rows are separated with a newline character. Lines starting with
#          a '#' character are ignored. Empty lines are ignored. Comments at
#          the end of line starting with '#' and continuing to end of line are
#          removed. Data table format:
#
#              [column 0] fieldname
#              -------------------
#              Name of field used as variable name containing result.
#
#              [column 1] default
#              --------------------
#              Default value. May be one of the following special values:
#
#                =REQUIRED - Bail if value is not supplied on the command line.
#
#                =PROMPT - Prompt if value is not supplied on the command line.
#
#              [column 2] label
#              ----------------
#              Short legible label for the field.
#
#              [column 3] description
#              ------------------------
#              More detailed description displayed in help message.
#
# STDOUT:  Interactive.
#
# VARS:  - Each field is exported as a variable with the user configured value.
#
#        - $fields: Output array of field names that were processed.
#
#        - $labels: Output array of labels corresponding to the fields list.
#
#        - $INIT: Input - specify a function to run after parsing STDIN data
#          but before displaying list for the first time. Init functions have
#          access to the following vars: fields (array), labels (array),
#          promptfns (array), displayfns (array), promptmessages (array).
#
#        - $PREPROCESS: Input - Name of a function to call to rewrite valid
#          lines. PREPROCESS(line). If specified, function should `echo` the
#          altered line.
#
#        - $PREFIX: Input - Text to insert before valid input lines. Alternate
#          way to do similar as PREPROCESS without writing a separate function.
#
#        - $PROMPT: Input - Message displayed during item selection. Default
#          is "Choose item or press [ENTER] to confirm"
#
#        - $SEPARATOR: Input - Column separator that delineates array items.
#          Default if not specified is "|".
#
# RETURN:  Unused
#
# USAGE EXAMPLE:
#
#  multiprompt "Fruity multiprompt" 4 <<EOF
#    # promptfn | displayfn   | dflt | fieldname | label    | promptmessage
#    # ---------+-------------+------+-----------+----------+-----------------
#      ynprompt | cboxdisplay | n    | cherries  | Cherries | Include cherries
#      ynprompt | cboxdisplay | n    | oranges   | Oranges  | Include oranges
#      ynprompt | cboxdisplay | n    | pears     | Pears    | Include pears
#      ynprompt | cboxdisplay | y    | lemons    | Lemons   | Include lemons
#      ynprompt | cboxdisplay | n    | limes     | Limes    | Include limes
#  EOF
#  for f in ${fields[@]}; do echo "$f: ${!f}"; done
#
# Note that this is a contrived example showing the features of multiprompt().
# See checkboxprompt or radioprompt for a better way to handle single on/off
# values and for examples how to extend this function with a simpler interface.
#
# See STDIN above for column definitions.
#
function argsprompt {

  # Variables init.
  local exitearly=$(get EARLYEXIT $(get FORCE_YES, 0))
  local title="$1"; shift
  local num_columns="$1"; shift
  local promptfn=$(get PROMPTFN textprompt)
  local displayfn=$(get DISPLAYFN display)
  local pfn
  local dfn

  if [ -z "$multiprompt_fields" ]; then

    local -a multiprompt_fields
    local -a multiprompt_defaults
    local -a multiprompt_labels
    local -a multiprompt_promptmsgs
    local -a multiprompt_visibility
    local -a multiprompt_promptfns
    local -a multiprompt_displayfns
    local -a argsprompt_required
    local -a argsprompt_longopts
    local -a argsprompt_shortopts
    local -a argsprompt_descriptions

    # Parse the config.
    read_arrays \
      multiprompt_fields \
      multiprompt_defaults \
      multiprompt_labels \
      multiprompt_promptmsgs \
      argsprompt_longopts \
      argsprompt_shortopts \
      argsprompt_descriptions \
      multiprompt_visibility \
      multiprompt_promptfns \
      multiprompt_displayfns

    for i in "${!multiprompt_fields[@]}"; do
      local dflt="${multiprompt_defaults[$i]}"
      local field="${multiprompt_fields[$i]}"
      [ "${dflt}" = "=GROUP" ] &&
        local defaultpfn="" ||
        local defaultpfn="${promptfn}"
      [ -n "${multiprompt_promptfns[$i]}" ] &&
          pfn="${multiprompt_promptfns[$i]}" ||
          pfn="${defaultpfn}"
      [ -n "${multiprompt_displayfns[$i]}" ] &&
        dfn="${multiprompt_displayfns[$i]}" ||
        dfn="${displayfn}"
      case "${dflt}" in
        "=PROMPT"|"=REQUIRED")
          argsprompt_required["${#argsprompt_required[@]}"]="${field}"
        ;;
        *)
          [ -z "${!field}" ] && export ${multiprompt_fields[$i]}="${dflt}"
        ;;
      esac
      multiprompt_defaults[$i]="${dflt}"
      multiprompt_promptfns[$i]="${pfn}"
      multiprompt_displayfns[$i]="${dfn}"
    done

    # Parse arguments.
    while : ; do
      [ -z "$1" ] && break
      local i=0
      local handled=0
      while : ; do
        case "$1" in
          "${argsprompt_longopts[$i]}")
            export ${multiprompt_fields[$i]}=$2
            shift; shift
            handled=1
          ;;
          "${argsprompt_shortopts[$i]}")
            export ${multiprompt_fields[$i]}=$2
            shift; shift
            handled=2
          ;;
          ${argsprompt_longopts[$i]}=*)
            local v="$(sed "s/${argsprompt_longopts[$i]}=//g" <<< "$1")"
            export ${multiprompt_fields[$i]}="${v}"
            shift
            handled=3
          ;;
          ${argsprompt_shortopts[$i]}=*)
            local v="$(sed "s/${argsprompt_shortopts[$i]}=//g" <<< "$1")"
            export ${multiprompt_fields[$i]}="${v}"
            shift
            handled=4
          ;;
        esac
        i=$((i+1))
        [ $handled != 0 ] && break
        [ "$i" -ge "${#multiprompt_fields[@]}" ] && break
      done
      [ $handled = 0 ] && fatal "bad arg: '$1'" # TODO better error handling
    done

    # Check if we have all argsprompt_required fields.
    if [ $exitearly != 0 ]; then
      local hasrequired=1
      for field in "${argsprompt_required[@]}"; do
        if [ -n "${!field}" ]; then
          # Required field has a value, keep checking.
          continue
        else
          # Required field has no value, stop checking.
          hasrequired=0
          break
        fi
      done
      # Early exit if all argsprompt_required fields supplied and requested.
      [ $hasrequired = 1 ] && return 0
    fi
  fi

  # Do multiprompt until all required values are supplied.
  while : ; do
    PREFIX="" PREPROCESS="" multiprompt "${title}" "${num_columns}" <<< ""
    for field in "${argsprompt_required[@]}"; do
      [ -z "${!field}" ] && continue 2
    done
    break
  done
}

#------------------------------------------------------------------------------
# UI: checkboxes
#------------------------------------------------------------------------------

# ----------------------------------
# checkboxprompt(title, num_columns)
# ----------------------------------
#
# Simplified multiprompt that works with a group of related checkboxes. Upon
# completion, each supplied field will either have a value of 'y' or 'n'.
#
# ARGS:  - title: Text to show above the option listing.
#
#        - num_columns: Number of columns in the listing. Optional. Default=3.
#
# STDIN:   Rows of field records. Columns are separated with "|" by default
#          and rows are separated with a newline character. Lines starting with
#          a '#' character are ignored. Empty lines are ignored. Comments at
#          the end of line starting with '#' and continuing to end of line are
#          removed. Data table format:
#
#              [column 1] default
#              ------------------
#              Default value for the field. It will only be applied if the
#              variable of the field doesn't already contain a value. Must
#              contain value "y" or "n".
#
#              [column 2] fieldname
#              --------------------
#              Name of the field. Must be a single word name, it is used as
#              bash variable name.
#
#              [column 3] label
#              ----------------
#              Short label for the field. Used in list mode.
#
# STDOUT:  Interactive.
#
# VARS:  - Each field is exported as a variable set to 'y' or 'n'.
#
#        - $checked: Output array of all fields that were checked "on".
#
#        - $unchecked: Output array of all fields that were not checked "on".
#
#        - $fields: Output array of field names that were processed.
#
#        - $labels: Output array of labels corresponding to the fields array.
#
#        - $PROMPT: Input - Message displayed during item selection. Default is
#          "Toggle items by number or press [ENTER] to confirm"
#
#        - $SEPARATOR: Input - Column separator that delineates array items.
#          Default if not specified is "|".
#
# RETURN:  Unused
#
# USAGE EXAMPLE:
#
#   prompt name "What's your first name"
#   checkboxprompt "Choose Yoour Froots, $name" 3 <<EOF
#     # default |  fieldname    |  label
#     # -------------+----------+------------
#       n       |  cherries     |  Cherries
#       n       |  oranges      |  Oranges
#       n       |  blueberries  |  Blueberries
#       n       |  pears        |  Pears
#       y       |  lemons       |  Lemons
#       n       |  limes        |  Limes
#       n       |  grapes       |  Grapes
#       n       |  raspberries  |  Raspberries
#       n       |  mango        |  Mango
#       n       |  pomegranite  |  Pomegranite
#   EOF
#   [ -z "$checked" ] && checked="nothing!"
#   [ -z "$unchecked" ] && unchecked="nothing!"
#   echo "$name likes: $checked"
#   echo "$name hates: $unchecked"
#   echo "$name likes cherries? $cherries"
#
# See STDIN above for column definitions.
#
function checkboxprompt {
  [ -n "$PROMPT" ] && promptmsg="$PROMPT" || \
    promptmsg="Toggle items by number or press [ENTER] to confirm"
  PREPROCESS="cboxpreprocess" PROMPT="$promptmsg" GROUP="" multiprompt "$1" "$2"
  unset unchecked
  unset checked
  for f in "${multiprompt_fields[@]}"; do
    [ "${!f}" = "y" ] && checked+="$f " || unchecked+="$f "
  done
  export checked
  export unchecked
}

# --------------------
# cboxpreprocess(line)
# --------------------
#
# PREPROCESS() implementation used by checkboxprompt().
#
# See read_filtered() / VARS / PREPROCESS for details.
#
# ARGS:  - line: Line to preprocess.
#
# STDIN:   Unused
#
# STDOUT:  checkboxprompt overrides.
#
# VARS:    None
#
# RETURN:  Unused
#
function cboxpreprocess {
  echo "cboxprompt | cboxdisplay | $1 |"
}

#------------------------------------------------------------------------------
# UI: radio buttons
#------------------------------------------------------------------------------

# ----------------------------------------
# radioprompt(default, title, num_columns)
# ----------------------------------------
#
# Simplified multiprompt that works with a group of related checkboxes. Upon
# completion, each supplied field will either have a value of 'y' or 'n'.
#
# ARGS:  - default: Which option is selected by default. Must be a field in the
#          STDIN data or item #1 will be selected by default.
#
#        - title: Text to show above the option listing.
#
#        - num_columns: Number of columns in the listing. Optional. Default=3.
#
# STDIN:   Rows of field records. Columns are separated with "|" by default
#          and rows are separated with a newline character. Lines starting with
#          a '#' character are ignored. Empty lines are ignored. Comments at
#          the end of line starting with '#' and continuing to end of line are
#          removed. Data table format:
#
#              [column 1] default
#              ------------------
#              Default value for the field. It will only be applied if the
#              variable of the field doesn't already contain a value. Must
#              contain value "y" or "n".
#
#              [column 2] fieldname
#              --------------------
#              Name of the field. Must be a single word name, it is used as
#              bash variable name.
#
#              [column 3] label
#              ----------------
#              Short label for the field. Used in list mode.
#
# STDOUT:  Interactive.
#
# VARS:  - $selected_value: Value selected by the user.
#
#        - $selected_label: Label for the value selected by the user.
#
#        - $selected_index: Item selected by the user.
#
#        - $fields: Output array of field names that were processed.
#
#        - $labels: Output array of labels corresponding to the fields array.
#
#        - $PROMPT: Input - Message displayed during item selection. Default is
#          "Toggle items by number or press [ENTER] to confirm"
#
#        - $SEPARATOR: Input - Column separator that delineates array items.
#          Default if not specified is "|".
#
# RETURN:  Unused
#
# USAGE EXAMPLE:
#
#   radioprompt "raspberries" "Choose Yoour Froot" 3 <<EOF
#     # -------------+----------------------
#     # value        |   label
#     # -------------+----------------------
#       cherries     |   Cherries
#       oranges      |   Oranges
#       blueberries  |   Blueberries
#       pears        |   Pears
#       lemons       |   Lemons
#       limes        |   Limes
#   EOF
#   echo "You picked: $selected_label ($selected_value)"
#
# See STDIN above for column definitions.
#
function radioprompt {
  [ -z "$3" ] && ncolumns=3 || ncolumns="$3"
  [ -n "$PROMPT" ] && msg="$PROMPT" || \
    msg="Toggle items by number or press [ENTER] to confirm"
  export selected_value="$1"
  PREPROCESS="radpreprocess" INIT="radinit" PROMPT="$msg" GROUP="" \
    multiprompt "$2" "$ncolumns"
}

# -------------------
# radpreprocess(line)
# -------------------
#
# PREPROCESS() implementation used by radioprompt().
#
# See read_filtered() / VARS / PREPROCESS for details.
#
# ARGS:  - line: Line to preprocess.
#
# STDIN:   Unused
#
# STDOUT:  radioprompt overrides.
#
# VARS:    None
#
# RETURN:  Unused
function radpreprocess {
  echo "radprompt | raddisplay | | $1 |"
}

# ---------
# radinit()
# ---------
#
# INIT() implementation used by radioprompt().
#
# See multiprompt() / VARS / INIT for details.
#
# ARGS:    None
#
# STDIN:   Unused
#
# STDOUT:  Unused
#
# VARS:  - $selected_value: Value selected by the user.
#
#        - $selected_label: Label for the value selected by the user.
#
#        - $selected_index: Item selected by the user.
#
# RETURN:  Unused
#
function radinit {
  # Figure out the $selected_index using the $selected_value and fields array.
  n=1
  for field in "${multiprompt_fields[@]}"; do
    # If field value equals selected value, we found the $selected_index ($n).
    [ "${selected_value}" = "${field}" ] && break
    n=$((n+1))
  done
  if [ ${#multiprompt_fields[@]} = $(($n-1)) ]; then
    # There was no valid $selected_value so pick "1" and configure for it.
    n=1
    export selected_value="${multiprompt_fields[$n]}"
  fi
  export selected_index="$n"
  export selected_label="${multiprompt_labels[$n]}"
}

#------------------------------------------------------------------------------
# SERVER COMMAND: ping
#------------------------------------------------------------------------------

function ping_preflight {
  return 0
}

function ping_command {
  uname -a
  return 0
}

#------------------------------------------------------------------------------
# SERVER COMMAND: apache2_init
#------------------------------------------------------------------------------

apache2_init_DEPS="apache2ctl a2ensite a2dissite a2enmod a2dismod"
package_Ubuntu_apache2ctl="apache2"
package_Ubuntu_a2ensite="apache2"
package_Ubuntu_a2dissite="apache2"
package_Ubuntu_a2enmod="apache2"
package_Ubuntu_a2dismod="apache2"

function apache2_init_preflight {
  echo "+INFO testing 123"
  if [ ! -d "$1" ]; then
    PREFLGHT_ERROR="Cannot read Apache2 config directory '$1'."
    return 1
  fi
  local -a sudo_missing
  for dep in ${apache2_init_DEPS}; do
    local varname="$(${AWK} '{print toupper($0)}' <<< "${dep}")"
    local line="$USER ALL = NOPASSWD:${!varname}"
    grep "${line}" /etc/sudoers || sudo_missing[${#sudo_missing[@]}]="${line}"
  done
  printf $'+INFO  - %s\n' "${sudo_missing[@]}"
  #if [ ${#sudo_missing[@]} > 0 ]; then
  #  # TODO print the sudo_missing list of lines.
  #  if ynprompt "Add these lines to /etc/sudoers?"; then
  #    # TODO be more careful about existing sudoers.new if exists.
  #    local missing="$(printf $'%s\n' "${sudo_missing[@]}")"
  #    sed "/# User privilege specification/${missing}\n" /etc/sudoers |
  #      sudo ${TEE} /etc/sudoers.new
  #  fi
  #fi
  return 0
}

function apache2_init_command {
  echo "+INFO testing 456"
  echo "$1"
  return 0
}


#------------------------------------------------------------------------------
# SERVER COMMAND: init_vhost
#------------------------------------------------------------------------------

function init_vhost_preflight {
  preflight_sudo || return 1
  return 0
}

function init_vhost_command {
  echo
}

#------------------------------------------------------------------------------
# USER COMMAND: init
#------------------------------------------------------------------------------

# Utility: Common initilization for the init[7|8]? commands.
function init_init {
  mkdir -p "$SCRIPTHOME"
  if [ ! -d "$SCRIPTHOME" ]; then
    echo "Could not create $SCRIPTHOME program directory."
    exit 1
  fi
  mkdir -p "$SCRIPTHOME/hooks"
  mkdir -p "$SCRIPTHOME/servers"
  mkdir -p "$SCRIPTHOME/settings"
  mkdir -p "$SCRIPTHOME/settings/modules"
  mkdir -p "$SCRIPTHOME/settings/themes"
  mkdir -p "$SCRIPTHOME/cache"
  [ -f "$SCRIPTHOME/cache/project.xml" ] || update_command
  return 0
}

function init_shorthelp {
  echo "Alias for init7 currently. Will change to init8."
}

function init_help {
  help_init7
}

function init_command {
  init7 $@
}

#------------------------------------------------------------------------------
# USER COMMAND: init7
#------------------------------------------------------------------------------

function init7_shorthelp {
  echo "Create a Drupal 7 installation."
}

function init7_help {
  echo "TODO help_init7"
}

function init7_command {
  echo "init7 ARGS: $@"
  ERROR=`init_init`
  [ $? != 0 ] && fatal "Initialization error: $ERROR"
  sshcmd monkeysatkeyboards.com fletch init_vhost
}

#------------------------------------------------------------------------------
# USER COMMAND: init8
#------------------------------------------------------------------------------

function init8_shorthelp {
  echo "Create a Drupal 8 installation."
}

function init8_help {
  echo "TODO help_init8"
}

function init8_command {
  ERROR=`init_init`
  [ $? != 0 ] && fatal "Initialization error: $ERROR"
  echo "init8 ARGS: $@"
}

#------------------------------------------------------------------------------
# USER COMMAND: servers
#------------------------------------------------------------------------------

function servers_shorthelp {
  echo "List available servers."
}

function servers_help {
  echo "TODO help_servers"
}

function servers_command {
  ls "$SCRIPTHOME/servers" | sed 's/.server//g'
}

#------------------------------------------------------------------------------
# USER COMMAND: addserver
#------------------------------------------------------------------------------

read -d "" addserver_CONFIG <<EOF

  addserver_alias | =PROMPT | \
    Alias | Enter a short lowercase alias | \
    --alias | -a | A short aliased name for the host.

  addserver_roles | dtp | \
    Roles | | \
    --roles | -r | Role(s) the server will provide. Value can include one or \
                   more of [ldtp] which stand for (l)ocal (d)evelopment \
                   (t)testing and (p)roduction. It is not recommended to \
                   combine [l] with any other roles, doing so will cause a \
                   warning prompt to be displayed. | \
    | addserver_roles_prompt | addserver_roles_display

  addserver_host | =PROMPT | \
    Host | Enter the server's host name | \
    --host  | -h | Host name.

  addserver_user | $(get user =PROMPT) | \
    User | Enter the remote user name | \
    --user | -u | User name.

  addserver_identity | | \
    SSH identity file | Path to SSH .pem identity file. | \
    --identity-file | -i | SSH identity file path (optional).

  addserver_sshopts | | \
    SSH options | Additional SSH options. | \
    --ssh-options | -o | Additional SSH options (optional).

  addserver_database | =GROUP | \
    Database settings | Choose item to edit or press [ENTER] to return | | | | | \
    | addserver_database_display

  addserver_dbtype | mysql | \
    Database type | Database type | \
    --db-type | -d | Database type (currently only mysql). | \
    addserver_database | addserver_dbtype_prompt

  addserver_dbuser | =PROMPT | \
    Database user | Database user | \
    --db-user | -U | Database user with permission to create databases. | \
    addserver_database

  addserver_dbpass | | \
    Database password | Database password | \
    --db-password | -p | Database password. | \
    addserver_database | pwprompt

  addserver_httpd | =GROUP | \
    Web server settings | Choose item to edit or press [ENTER] to return | | | | | \
    | addserver_httpd_display

  addserver_httpdtype | apache2 | \
    Web server type | Web server type | \
    --httpd-type | -H | Web server type (currently only apache2). | \
    addserver_httpd | addserver_httpdtype_prompt

  addserver_apache2conf | /etc/apache2 | \
    Apache 2 configuration directory | Apache 2 configuration directory | \
    --apache2-conf | -c | Apache 2 configuration directory. | \
    addserver_httpd[addserver_httpdtype=apache2]

  addserver_apache2logs | /var/log/apache2 | \
    Apache 2 logs directory | Apache 2 logs directory | \
    --apache2-logs | -l | Apache 2 logs directory. | \
    addserver_httpd[addserver_httpdtype=apache2]

  addserver_apache2vhosts | | \
    Apache 2 virtual hosts config | Apache 2 virtual hosts config | \
    || Apache 2 virtual hosts config. | \
    addserver_httpd[addserver_httpdtype=apache2] | \
    addserver_apache2vhosts_prompt

EOF

# TODO: E-mail prompt for ServerAdmin.
read -d "" addserver_apache2vhosts_RECORD <<EOF
  cboxprompt | cboxdisplay |  n   | ssl   | Enable SSL
  textprompt | display     | *:80 | name  | NameVirtualHost | NameVirtualHost name (e.g. *:80)
  textprompt | display     |      | admin | ServerAdmin     | Server admin e-mail address
EOF

read -d "" addserver_roles_CHECKBOXES <<EOF
  n  |  addserver_roles_local       |  Local development
  y  |  addserver_roles_dev         |  Development server
  y  |  addserver_roles_testing     |  Testing server
  y  |  addserver_roles_production  |  Production server
EOF

function addserver_roles_sanitize {
  local roles=""
  string_contains "${addserver_roles}" "l" && roles+=l
  string_contains "${addserver_roles}" "d" && roles+=d
  string_contains "${addserver_roles}" "t" && roles+=t
  string_contains "${addserver_roles}" "p" && roles+=p
  export addserver_roles="${roles}"
}

function addserver_roles_prompt {
  addserver_roles_sanitize
  local -r field="$1"
  local roles=""
  local addserver_roles_local=n
  local addserver_roles_dev=n
  local addserver_roles_testing=n
  local addserver_roles_production=n
  string_contains "${addserver_roles}" "l" && addserver_roles_local=y
  string_contains "${addserver_roles}" "d" && addserver_roles_dev=y
  string_contains "${addserver_roles}" "t" && addserver_roles_testing=y
  string_contains "${addserver_roles}" "p" && addserver_roles_production=y
  checkboxprompt "Select server roles" 2 <<< "${addserver_roles_CHECKBOXES}"
  [ "${addserver_roles_local}" = y ] && roles+="l"
  [ "${addserver_roles_dev}" = y ] && roles+="d"
  [ "${addserver_roles_testing}" = y ] && roles+="t"
  [ "${addserver_roles_production}" = y ] && roles+="p"
  export addserver_roles="${roles}"
}

function addserver_roles_display {
  addserver_roles_sanitize
  local -r roles=( ${addserver_roles} )
  local display=""
  for (( i=0; i<${#roles}; i++ )); do
    [ ${roles:$i:1} = l ] && display+="local "
    [ ${roles:$i:1} = d ] && display+="development "
    [ ${roles:$i:1} = t ] && display+="testing "
    [ ${roles:$i:1} = p ] && display+="production "
  done
  display="$(sed 's/[[:space:]]$//g' <<< "${display}" | sed 's/ /, /g')"
  printf "Roles: %s" "${display}"
}

function addserver_apache2vhosts_display {
  local -r records="$1"
  local -r key="$2"
  local -r namefield="${records}_${key}_name"
  local -r name="${!namefield}"
  echo "NameVirtualHost ${name}"
}

function addserver_apache2vhosts_prompt {
  GROUP="" \
    recordsprompt apache2vhosts "virtual host" \
    addserver_apache2vhosts_display <<< "${addserver_apache2vhosts_RECORD}"
}

function addserver_httpdtype_prompt {
  local -r addserver_httpdtype_prompt_field="$1"
  PROMPT="" radioprompt "${!addserver_httpdtype_prompt_field}" "$2" 3 <<EOF
    apache2 |   Apache 2
    nginx   |   Nginx
EOF
  export ${addserver_httpdtype_prompt_field}="${selected_value}"
}

function addserver_database_display {
  dbuser=$(get addserver_dbuser "[USER NOT SET]")
  [ -n "${addserver_dbpass}" ] &&
    dbpass="[PASSWORD SET]" ||
    dbpass="[NO PASSWORD]"
  echo "$2: ${addserver_dbtype} / ${dbuser} / ${dbpass}"
}

function addserver_httpd_display {
  echo "$2: ${addserver_httpdtype}"
}

function addserver_shorthelp {
  echo "Add a new server."
}

function addserver_help {
  argshelp addserver_CONFIG "$PROGRAM $1 (ARGUMENTS)" <<EOL
  TODO addserver help
EOL
}

function addserver_preflight {

  # Init ~/.ddo
  if ! init_init; then
    PREFLGHT_ERROR="Cannot initialize program directory $SCRIPTHOME."
    return 1
  fi

  # Test access to $SCRIPTHOME/servers
  f="$SCRIPTHOME/servers/TESTFILE"
  touch "$f"
  if [ -f "$f" ]; then
    rm -f "$f"
  else
    PREFLGHT_ERROR="Cannot write to servers directory $SCRIPTHOME/servers."
    return 1
  fi

  # Preflight passed.
  return 0
}

function addserver_command_init {
  [ -z "${apache2vhosts_0_name}" ] &&
    export apache2vhosts_0_name="*:80"
  [ -z "${apache2vhosts_0_ssl}" ] &&
    export apache2vhosts_0_ssl=n
  [ -z "${apache2vhosts_0_admin}" ] &&
  [ -n "${addserver_user}" ] &&
  [ -n "${addserver_host}" ] &&
    export apache2vhosts_0_admin="${addserver_user}@${addserver_host}"
  [ -z "${apache2vhosts_1_name}" ] &&
    export apache2vhosts_1_name="*:443"
  [ -z "${apache2vhosts_1_ssl}" ] &&
    export apache2vhosts_1_ssl=y
  [ -z "${apache2vhosts_1_admin}" ] &&
  [ -n "${addserver_user}" ] &&
  [ -n "${addserver_host}" ] &&
    export apache2vhosts_1_admin="${addserver_user}@${addserver_host}"
}

function addserver_command {

  # Process arguments.
  INIT="addserver_command_init" \
  PROMPT="Choose item to edit or press [ENTER] to test access and save" \
    argsprompt "Add a new server" 1 "$@" <<< "${addserver_CONFIG}"

  # Check output file.
  file="$SCRIPTHOME/servers/${addserver_alias}.server"
  [ -f "$file" ] && fatal "Server file \"${addserver_alias}.server\" already exists, cowardly refusing to overwrite existing server configuration."

  # Write output file.
  for f in ${fields[@]}; do
    local name=$(sed "s/addserver/${addserver_alias}/g" <<< ${f})
    echo "${name}=${!f}" >> "$file"
  done

  # Add apache vhosts to file.
  if [ "${addserver_httpdtype}" = "apache2" ]; then
    for key in $(recordskeys apache2vhosts); do
      local name="apache2vhosts_${key}_name"
      echo "${addserver_alias}_${name}=${!name}" >> "$file"
      local ssl="apache2vhosts_${key}_ssl"
      echo "${addserver_alias}_${ssl}=${!ssl}" >> "$file"
      local admin="apache2vhosts_${key}_admin"
      echo "${addserver_alias}_${admin}=${!admin}" >> "$file"
    done
  fi

  # Read output file and test.
  if ! loadserver "${addserver_alias}"; then
    rm -f "$file"
    fatal "Could not write server configuraion in $file."
  fi
  identity=$(get $(ns ${addserver_alias} _identity))
  user=$(get $(ns ${addserver_alias} _user))
  host=$(get $(ns ${addserver_alias} _host))
  opts=$(get $(ns ${addserver_alias} _sshopts))

  # Offer key exchange if the server is requiring a password.
  unset exchange_args
  local exchange_results="[NOT NEEDED]"
  if ssh_pw_required "${host}" "${user}" "${identity}" "${opts}"; then
    echo
    paragraph <<EOF
      The SSH command requires a password for user "${user}" at \
      host "${host}". It will ask for it quite often during normal \
      operations. If you wish, we can attempt a key exchange with the remote \
      server after which the password will not be required. Note that you can \
      skip this now and run \`${PROGRAM} keyexchange\` later to exchange keys.
EOF
    # Do key exchange if requested.
    if ynprompt v "Exchange public key with host ${host}?"; then
      echo; echo "Exchanging keys..."
      # TODO handle other key types.
      # TODO get better control of ssh-keygen here.
      [ -f ~/.ssh/id_rsa.pub ] || ssh-keygen -t rsa -b 4096
      if exchange_results="$(keyexchange ~/.ssh/id_rsa.pub "${addserver_alias}")"; then
        echo "Key exchange succeeded: ${exchange_results}"
      else
        echo "Key exchange failed, sorry. Server said: ${exchange_results}."
      fi
    fi
  fi

  # Test remote.
  echo
  printf "Testing remote access... "
  if remoteuname="$(remote "$addserver_alias" ping)"; then
    printf $'[OK]\n'
  else
    printf $'[ERROR]\n'
    rm -f "$file"
    fatal "Can't reach server, please check settings and try again."
  fi

  # Init remote.
  printf "Initialzing ${addserver_httpdtype} server... "
  case "${addserver_httpdtype}" in
    "apache2")
      remote "${addserver_alias}" apache2_init "${addserver_httpdconf}" &&
        printf "${result}"$' [OK]\n' || printf $'[ERROR]\n'
    ;;
    "nginx")
      # TODO nginx support.
    ;;
  esac

  # Report success.
  echo
  FORMAT="rblx" MARGIN="3" HEADER_FORMAT="lb" ROWSPACING="1" tableformat <<EOF
    Add new server
    _
    alias          | ${addserver_alias}
    user           | ${user}
    host           | ${host}
    system         | ${remoteuname}
    identity file  | $(get identity "[NOT SET]")
    options        | $(get opts "[NOT SET]")
    key exchange   | ${exchange_results}
EOF
  MARGIN="3" paragraph <<EOF
    _
    Connection to host ${host} with user ${user} is confirmed. Server with \
    alias "${addserver_alias}" was successfully configured.
    Note that user ${user}@${host} must have administrative privileges or \
    must be configured to use sudo.
EOF
# TODO note about what exact admin privs user needs above.
# TODO test apachectl access
}

#------------------------------------------------------------------------------
# SERVER COMMAND: keyexchange_remote
#------------------------------------------------------------------------------

function keyexchange_remote_command {

  # Parse the key.
  local key="$1"
  [ -z "$key" ] && fatal "No key given."

  local type pubkey id
  IFS=" " read type pubkey id <<< "${key}"
  [ -z "$type" ] || [ -z "${pubkey}" ] || [ -z "${id}" ] && fatal "Bad key format."

  # Append or write new key file.
  local keyfile=~/.ssh/authorized_keys
  if [ -f "${keyfile}" ]; then
    if grep "${pubkey}" "${keyfile}" >> /dev/null; then
      # Key already in authorized_keys.
      echo "Key is already in file ${keyfile}, skipping."
    else
      # Append the file.
      echo "${key}" >> "${keyfile}"
      grep "${pubkey}" "${keyfile}" >> /dev/null ||
        fatal "Could not append key to file ${keyfile}."
      echo "Added key to ${keyfile}."
    fi
  else
    # No existing file just write a new one.
    echo "${key}" > "${keyfile}"
    [ -f "${keyfile}" ] || fatal "Could not create file ${keyfile}."
    echo "Created ${keyfile}."
  fi
}

#------------------------------------------------------------------------------
# USER COMMAND: keyexchange
#------------------------------------------------------------------------------

# TODO: keyexchange_addkey arg-command here that calls ssh-keygen, and remove
# the ssh-keygen from addserver and use this instead.
# TODO: replace the hard-coded ~/.ssh/id_rsa.pub with a function that searches
# for public keys. Also maybe a custom prompt for picking .pub found in .ssh
# or some other arbitrary file.
read -d "" keyexchange_CONFIG << EOF

  keyexchange_server | =PROMPT | \
    Server alias | Server alias | \
    --server | -s | Server alias. | \
    | serverprompt

  keyexchange_keyfile | $(echo ~/.ssh/id_rsa.pub) | \
    Key file | Key file | \
    --file | -f | Key file. | \
    | fileprompt

EOF

function keyexchange_shorthelp {
  echo "Exchange SSH keys with a server."
}

function keyexchange_help {
  argshelp keyexchange_CONFIG "$PROGRAM $1 (ARGUMENTS)" <<EOL
  TODO keyexchange help
EOL
}

# Workhorse function for keyexchange command, also utility used by addserver.
function keyexchange {

  local keyfile="$1"
  local server="$2"

  # Read key file.
  if [ ! -f "$keyfile" ]; then
    echo "Could not open key file ${keyfile}."
    return 1
  fi
  read key < "$keyfile"
  if [ -z "$key" ]; then
    echo "Could not read key from file ${keyfile}."
    return 2
  fi

  # Load server data.
  if ! loadserver "${server}"; then
    echo "Cannot load server \"${server}\"."
    return 4
  fi
  user=$(get $(ns ${server} _user))
  host=$(get $(ns ${server} _host))
  identity=$(get $(ns ${server} _identity))
  opts=$(get $(ns ${server} _sshopts))

  # Execute remote key exchange command.
  local result="$(remote "${server}" keyexchange_remote "${key}")"
  if [ $? = 0 ]; then
    if ssh_pw_required "${host}" "${user}" "${identity}" "${opts}"; then
      [ -n "$result" ] &&
        echo "Reason unknown. Remote host said: \"$result\"." ||
        echo "Reason unknown."
      return 5
    else
      echo "$result"
      return 0
    fi
  else
    echo "$result"
    return 6
  fi
}

function keyexchange_command {

  # Process arguments.
  PROMPT="Choose item to edit or press [ENTER] to exchange keys" \
    argsprompt "Key exchange" 1 "$@" <<< "${keyexchange_CONFIG}"

  # Exchange keys.
  echo
  keyexchange "${keyexchange_keyfile}" "${keyexchange_server}"
}

#------------------------------------------------------------------------------
# USER COMMAND: modserver
#------------------------------------------------------------------------------

function modserver_shorthelp {
  echo "Modify an existing server."
}

function modserver_help {
  echo "TODO help_modserver"
}

function modserver_command {
  echo "modserver ARGS: $@"
}

#------------------------------------------------------------------------------
# USER COMMAND: delserver
#------------------------------------------------------------------------------

function delserver_shorthelp {
  echo "Remove a server."
}

function delserver_help {
  longhelp $1 "$PROGRAM $1 [SERVERNAME]" <<EOL
  Delete a server by alias. TODO WILL THIS AFFECT EXISTING PROJECTS?
EOL
}

function delserver_command {
  echo "delserver ARGS: $@"
}

#------------------------------------------------------------------------------
# USER COMMAND: update
#------------------------------------------------------------------------------

function update_shorthelp {
  echo "Update Drupal project information from updates.drupal.org."
}

function update_help {
  echo "TODO help_update"
}

function __update_modules {
  type=$1
  vers=$2
  output=$3
  echo -n "Updating $vers ${type}s... "
  xmllint --shell "${SCRIPTHOME}/cache/project.xml" <<< "cat /projects/project/project_status[text()=\"published\"]/../type[text()=\"project_${type}\"]/../api_versions/api_version[text()=\"${vers}\"]/../../short_name/text()" | grep -v " -------" | grep -v "/ >" > "$output"
  echo `wc -l "$output" | sed "s/[^0-9]//g"` "found."
}

function _update_modules {
  __update_modules module 7.x "$SCRIPTHOME/cache/module-7.x"
  __update_modules theme 7.x "$SCRIPTHOME/cache/theme-7.x"
  __update_modules module 8.x "$SCRIPTHOME/cache/module-8.x"
  __update_modules theme 8.x "$SCRIPTHOME/cache/theme-8.x"
}
#_update_modules

function update_command {
  rm -f $SCRIPTHOME/cache/project.xml
  wget http://updates.drupal.org/release-history/project-list/all -O $SCRIPTHOME/cache/project.xml
  _update_modules
  echo "TODO update"
}

#------------------------------------------------------------------------------
# USER COMMAND: help
#------------------------------------------------------------------------------

help_DEPS="tr fmt"
package_Cygwin_tr="coreutils"
package_Cygwin_fmt="coreutils"

function help_shorthelp {
  echo "Display a help message."
}

function help_help {
  longhelp $1 "$PROGRAM $1" "$PROGRAM $1 [COMMAND]" <<EOL
  Yo dawg I heard you like help with your help. So I'm here to help.

  The 'drupal help' form of the command shows a list of commands and main
  program usage.

  The 'drupal help [COMMAND]' form displays help for a specified command.
EOL
}

function help_preflight {
  PREFLGHT_ERROR="This is an fatal."
  return 0
}

function help_command {
  if test -z "$1"; then
    usage
    exit 0
  else
    echo
    if ! valid_command "$1"; then
      usage "No help for unknown command \"$1\""; exit -3;
    fi
    $(ns $1 _help) $1
  fi
}

#------------------------------------------------------------------------------
# OS specific package management
#------------------------------------------------------------------------------

# Package manager function for Cygwin.
function package_Cygwin {
  echo " - Please use Cygwin setup.exe to install package \"$*\"."
}

# Package manager function for Ubuntu.
function package_Ubuntu {
  sudo apt-get install "$*"
}

#------------------------------------------------------------------------------
# Initialization.
#------------------------------------------------------------------------------
REMOTE=0
declare -a PREFLIGHT_ERRORS
declare -a PREFLIGHT_WARNINGS
flightcheck=0
declare -a commands
declare invalid_commands
SED="sed" # needed because ns uses it, will be replaced in deps processing.

prog LSB_RELEASE lsb_release && OS="$(${LSB_RELEASE} -si)" || OS="$(uname -o)"

PM_INSTALL=$(ns package_ $OS)

# This and the -i switch in the hashbang at the top of the file are necessary
# to read COLUMNS shell var.
kill -s WINCH $$

# Parse arguments.
[ -z "${arguments}" ] && arguments=( "$@" )

declare i=0
declare command
for argument in "${arguments[@]}"; do
  if [ "${argument}" = "--remote" ]; then
    REMOTE=1
  elif [ "${argument}" = "--" ]; then
    [ -n "$command" ] && commands[$i]="$command"
    i=$((i+1))
    unset command
  else
    [ -z "$command" ] && command="$argument" || command+=`printf " %q" "$argument"`
  fi
done
[ -n "$command" ] && commands[$i]="$command"
[ $REMOTE = 1 ] && COMMANDS="${SERVER_COMMANDS}" || COMMANDS="${USER_COMMANDS}"

# Check the commands.
for command_and_args in "${commands[@]}"; do
  acommand=($command_and_args)
  command="${acommand[0]}"
  if ! valid_command $command; then
    [ -n "${invalid_commands[*]}" ] && invalid_commands+=" "
    invalid_commands+=$command
  fi
done

# Collect deps.
declare deps="${DEPS}"
for command_and_args in "${commands[@]}"; do
  acommand=($command_and_args)
  command="${acommand[0]}"
  command_DEPS=$(ns $command _DEPS)
  if [ -n "${!command_DEPS}" ]; then
    [ -n "${deps}" ] && deps+=" "
    deps+="${!command_DEPS}"
  fi
done

# Find missing deps.
declare missing
for dep in "${deps[@]}"; do
  prog DEP $dep || missing+="$dep "
done

# Process missing deps.
if [ -n "$missing" ]; then

  echo -e "\nMissing tools..."

  # Gather info about the tool packages.
  unset packages
  for item in $missing; do
    package=$(ns package_ $OS _ $item)
    if [ -z "${!package}" ] || ! func ${PM_INSTALL}; then
      echo " - $item: no suggestion on how to install, sorry"
      continue
    fi
    packages+="${!package}"
  done

  # Run package manager.
  packages=`echo "$packages" | xargs -n1 | sort -u | xargs` # unique, sorted
  for package in $packages; do
    ${PM_INSTALL} ${package}
  done

  # Did that solve it?
  unset still_missing
  for item in $missing; do
    prog DEP $item || still_missing+="$item "
  done

  # Report.
  echo
  if [ -n "$still_missing" ]; then
    echo "Could not automatically resolve the following missing tools: $still_missing" ||
    exit 1
  else
    echo "Automatically resolved missing deps \"$missing\"."
  fi
fi

# Process deps.
prog _AWK awk # temp need for loop below.
for dep in ${deps}; do
  depname=`echo $dep | $_AWK '{print toupper($0)}'`
  prog $depname $dep
done
unset _AWK
unset missing

# Set up the temporary directory.
[ ! -d "$TEMPDIR" ] &&
  fatal "Could not create temporary directory, exiting."
echo "TESTVALUE" > "$TEMPDIR/writecheck"
[ -f "$TEMPDIR/writecheck" ] &&
  grep "TESTVALUE" "$TEMPDIR/writecheck" >> /dev/null &&
  rm "$TEMPDIR/writecheck" ||
  fatal "Could not write to temporary directory, exiting."

# Did we understand all the commands?
[ -z "$commands[*]" ] && fatal "No command given"
[ -n "${invalid_commands[*]}" ] && \
  fatal "Unknown command(s) \"$invalid_commands\". Try \`$PROGRAM help\`."

# UTF-8 autodetect
#if [ $REMOTE != 1 ]; then
#  CHARMAP=$(locale charmap)
#  if [ "${CHARMAP}" != "UTF-8" ]; then
#    echo
#    paragraph <<< "It looks like your terminal might not be configured to support UTF-8 characters. Would you like to use plain ASCII mode instead?"
#    ynprompt v "Press 'y' to continue in UTF-8 mode or 'n' to change to ASCII." y || OUTPUT_MODE="ascii"
#  fi
#fi

# Preflght checks.
for command_and_args in "${commands[@]}"; do
  eval "aargs=( ${command_and_args} )"
  command="${aargs[0]}"
  args=( "${aargs[@]:1}" )
  preflightfns=( $(ns $command _preflight _ $OS) $(ns $command _preflight) )
  for preflightfn in ${preflightfns[@]}; do
    func ${preflightfn} || continue
    unset PREFLGHT_ERROR
    ${preflightfn} ${args}
    result=$?
    flightcheck=$(( $flightcheck | $result ))
    [ $result ] && [ -n "$PREFLGHT_ERROR" ] && PREFLIGHT_ERRORS[${#PREFLIGHT_ERRORS[@]}]="$PREFLGHT_ERROR"
    [ $result ] && [ -n "$PREFLIGHT_WARNING" ] && PREFLIGHT_WARNINGS[${#PREFLIGHT_WARNINGS[@]}]="$PREFLIGHT_WARNING"
    break; # Only invoke 1 version of preflight func.
  done
done
if [ $flightcheck != 0 ]; then
  echo "${PREFLIGHT_ERRORS[*]}"
  fatal "Did not pass preflight checks: ${PREFLIGHT_ERRORS[*]}" # TODO list ERRORs
fi

# Main.
for command_and_args in "${commands[@]}"; do
  eval "aargs=( ${command_and_args} )"
  command="${aargs[0]}"
  args=( "${aargs[@]:1}" )
  commandfns=( $(ns $command _command _ $OS) $(ns $command _command) )
  for commandfn in ${commandfns[@]}; do
    func ${commandfn} || continue
    ${commandfn} "${args[@]}"
    break; # Only invoke 1 version of command func.
  done
done
